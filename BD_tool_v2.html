<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èŠ¯ç‰‡è®¾è®¡é›†æˆå·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        .canvas-container {
            position: relative;
            overflow: hidden;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
        }

        #padCanvas {
            cursor: grab;
        }

        #padCanvas:active {
            cursor: grabbing;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
    </style>
</head>

<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto p-4">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">èŠ¯ç‰‡è®¾è®¡é›†æˆå·¥å…·</h1>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <!-- æ§åˆ¶é¢æ¿ -->
            <div class="lg:col-span-1 bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">æ§åˆ¶é¢æ¿</h2>

                <!-- æ–‡ä»¶ä¸Šä¼  -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">ä¸Šä¼ Excelæ–‡ä»¶</label>
                    <input type="file" id="fileInput" accept=".xlsx,.xls"
                        class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                    <p class="text-xs text-gray-500 mt-1">æ”¯æŒåŒ…å«Die Sizeå’ŒPAD Coordinatesçš„Excelæ–‡ä»¶</p>
                </div>

                <!-- èŠ¯ç‰‡å°ºå¯¸æ˜¾ç¤º -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3 text-gray-700">èŠ¯ç‰‡å°ºå¯¸</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-sm text-gray-600 mb-1">é•¿åº¦ (Î¼m)</label>
                            <input type="number" id="chipSizeX" value="5000"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label class="block text-sm text-gray-600 mb-1">å®½åº¦ (Î¼m)</label>
                            <input type="number" id="chipSizeY" value="5000"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                    </div>
                </div>

                <!-- è§†å›¾æ§åˆ¶ -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3 text-gray-700">è§†å›¾æ§åˆ¶</h3>
                    <div class="flex gap-2 mb-3">
                        <button id="zoomIn"
                            class="flex-1 px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors">æ”¾å¤§</button>
                        <button id="zoomOut"
                            class="flex-1 px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors">ç¼©å°</button>
                    </div>
                    <button id="resetView"
                        class="w-full px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition-colors">é‡ç½®è§†å›¾</button>
                </div>

                <!-- å¯¼å‡ºåŠŸèƒ½ -->
                <div class="space-y-3 mb-6">
                    <h3 class="text-lg font-medium text-gray-700">å¯¼å‡ºåŠŸèƒ½</h3>
                    <button id="exportImage"
                        class="w-full px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors">å¯¼å‡ºå›¾ç‰‡</button>
                    <button id="exportPDF"
                        class="w-full px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors">å¯¼å‡ºPDF</button>
                    <button id="exportPadLSP"
                        class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors">å¯¼å‡ºPADç»˜åˆ¶LSP</button>
                    <button id="exportD2PadLSP"
                        class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors">å¯¼å‡ºD2èŠ¯ç‰‡LSP</button>
                    <button id="exportWireLSP"
                        class="w-full px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors">å¯¼å‡ºè¿çº¿LSP</button>
                </div>

                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="p-4 bg-gray-50 rounded-md">
                    <h3 class="text-sm font-medium text-gray-700 mb-2">ç»Ÿè®¡ä¿¡æ¯</h3>
                    <div id="padCount" class="text-sm text-gray-600">PADæ•°é‡: 0</div>
                    <div id="vssCount" class="text-sm text-gray-600">VSS PAD: 0</div>
                    <div id="vddCount" class="text-sm text-gray-600">VDD PAD: 0</div>
                    <div id="wireCount" class="text-sm text-gray-600">è¿çº¿æ•°é‡: 0</div>
                    <div id="lfCount" class="text-sm text-gray-600">L/Fè¿çº¿: 0</div>
                </div>
            </div>

            <!-- å¯è§†åŒ–åŒºåŸŸ -->
            <div class="lg:col-span-3">
                <div class="canvas-container bg-white rounded-lg shadow-lg mb-4">
                    <canvas id="padCanvas" width="800" height="600" class="block"></canvas>
                    <div id="tooltip" class="tooltip"></div>
                </div>

                <!-- æ•°æ®é¢„è§ˆ -->
                <div id="dataPreview" class="bg-white rounded-lg shadow-lg p-4" style="display: none;">
                    <h3 class="text-lg font-medium mb-3 text-gray-700">æ•°æ®é¢„è§ˆ</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- PADæ•°æ®é¢„è§ˆ -->
                        <div>
                            <h4 class="text-md font-medium mb-2 text-gray-600">PADåæ ‡æ•°æ®</h4>
                            <div class="max-h-40 overflow-y-auto border rounded">
                                <table class="min-w-full text-xs">
                                    <thead class="bg-gray-50">
                                        <tr>
                                            <th class="px-2 py-1 text-left">ç¼–å·</th>
                                            <th class="px-2 py-1 text-left">X</th>
                                            <th class="px-2 py-1 text-left">Y</th>
                                            <th class="px-2 py-1 text-left">å°ºå¯¸</th>
                                        </tr>
                                    </thead>
                                    <tbody id="padPreviewTable" class="divide-y divide-gray-200">
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- è¿çº¿æ•°æ®é¢„è§ˆ -->
                        <div>
                            <h4 class="text-md font-medium mb-2 text-gray-600">è¿çº¿å…³ç³»æ•°æ®</h4>
                            <div class="max-h-40 overflow-y-auto border rounded">
                                <table class="min-w-full text-xs">
                                    <thead class="bg-gray-50">
                                        <tr>
                                            <th class="px-2 py-1 text-left">PIN</th>
                                            <th class="px-2 py-1 text-left">PAD</th>
                                        </tr>
                                    </thead>
                                    <tbody id="wirePreviewTable" class="divide-y divide-gray-200">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class IntegratedChipTool {
            constructor() {
                this.canvas = document.getElementById('padCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.tooltip = document.getElementById('tooltip');

                this.pads = [];
                this.wireConnections = [];
                this.lfConnections = []; // æ–°å¢ï¼šå­˜å‚¨L/Fè¿çº¿
                this.padToPadConnections = []; // æ–°å¢ï¼šå­˜å‚¨PAD to PADè¿çº¿
                this.totalPinCount = 0; // æ–°å¢ï¼šå­˜å‚¨æ€»PINæ•°é‡
                this.chipSizeX = 5000;
                this.chipSizeY = 5000;

                // D2èŠ¯ç‰‡æ•°æ®
                this.d2Pads = [];
                this.d2ChipSizeX = 0;
                this.d2ChipSizeY = 0;
                this.hasD2Chip = false;

                this.scale = 0.1;
                this.offsetX = 50;
                this.offsetY = 50;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.lastExcelFileName = null;

                this.initEventListeners();
                this.resizeCanvas();
            }

            initEventListeners() {
                // æ–‡ä»¶ä¸Šä¼ 
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                // èŠ¯ç‰‡å°ºå¯¸å˜åŒ–
                document.getElementById('chipSizeX').addEventListener('change', (e) => {
                    this.chipSizeX = parseFloat(e.target.value) || 5000;
                    this.draw();
                });

                document.getElementById('chipSizeY').addEventListener('change', (e) => {
                    this.chipSizeY = parseFloat(e.target.value) || 5000;
                    this.draw();
                });

                // ç¼©æ”¾æ§åˆ¶
                document.getElementById('zoomIn').addEventListener('click', () => {
                    this.scale *= 1.2;
                    this.draw();
                });

                document.getElementById('zoomOut').addEventListener('click', () => {
                    this.scale /= 1.2;
                    this.draw();
                });

                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });

                // Canvasäº‹ä»¶
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // å¯¼å‡ºåŠŸèƒ½
                document.getElementById('exportImage').addEventListener('click', () => {
                    this.exportToImage();
                });
                document.getElementById('exportPDF').addEventListener('click', () => {
                    this.exportToPDF();
                });
                document.getElementById('exportPadLSP').addEventListener('click', () => {
                    this.exportPadLSP();
                });
                document.getElementById('exportD2PadLSP').addEventListener('click', () => {
                    this.exportD2PadLSP();
                });
                document.getElementById('exportWireLSP').addEventListener('click', () => {
                    this.exportWireLSP();
                });

                // çª—å£å¤§å°å˜åŒ–
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth - 4;
                this.canvas.height = Math.max(600, window.innerHeight - 200);
                this.draw();
            }

            handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                this.lastExcelFileName = file.name;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });

                        console.log(`ğŸ“‹ Excelæ–‡ä»¶åŒ…å« ${workbook.SheetNames.length} ä¸ªå·¥ä½œè¡¨: ${workbook.SheetNames.join(', ')}`);

                        // æ£€æŸ¥æ˜¯å¦æœ‰D2å·¥ä½œè¡¨
                        const hasD2Sheet = workbook.SheetNames.some(name => name.toUpperCase() === 'D2');
                        if (hasD2Sheet) {
                            console.log('ğŸ” æ£€æµ‹åˆ°D2å·¥ä½œè¡¨ï¼Œå°†è§£æç¬¬äºŒé¢—èŠ¯ç‰‡æ•°æ®');
                            this.hasD2Chip = true;
                        }

                        // å°è¯•è§£ææ¯ä¸ªå·¥ä½œè¡¨
                        let parseSuccess = false;
                        let mainChipParsed = false;

                        for (let i = 0; i < workbook.SheetNames.length; i++) {
                            const sheetName = workbook.SheetNames[i];
                            const worksheet = workbook.Sheets[sheetName];

                            console.log(`\nğŸ” æ­£åœ¨å°è¯•è§£æå·¥ä½œè¡¨ ${i + 1}/${workbook.SheetNames.length}: "${sheetName}"`);

                            // å¦‚æœæ˜¯D2å·¥ä½œè¡¨ï¼Œä½¿ç”¨ä¸“é—¨çš„è§£æå‡½æ•°
                            if (sheetName.toUpperCase() === 'D2') {
                                try {
                                    this.parseD2ChipData(worksheet);
                                    console.log(`âœ… æˆåŠŸè§£æD2èŠ¯ç‰‡æ•°æ®`);
                                } catch (error) {
                                    console.log(`âŒ D2å·¥ä½œè¡¨è§£æå¤±è´¥:`, error.message);
                                    console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', error);
                                }
                                continue;
                            }

                            // å¦‚æœä¸»èŠ¯ç‰‡å·²ç»è§£ææˆåŠŸï¼Œè·³è¿‡å…¶ä»–éD2å·¥ä½œè¡¨
                            if (mainChipParsed) {
                                continue;
                            }

                            try {
                                parseSuccess = this.parseExcelData(worksheet, sheetName);

                                if (parseSuccess) {
                                    console.log(`âœ… æˆåŠŸä»å·¥ä½œè¡¨ "${sheetName}" è§£æåˆ°æ•°æ®!`);
                                    mainChipParsed = true;
                                    // ä¸è¦breakï¼Œç»§ç»­æŸ¥æ‰¾D2å·¥ä½œè¡¨
                                } else {
                                    console.log(`âŒ å·¥ä½œè¡¨ "${sheetName}" æœªæ‰¾åˆ°æœ‰æ•ˆçš„PADæ•°æ®`);
                                }
                            } catch (error) {
                                console.log(`âŒ å·¥ä½œè¡¨ "${sheetName}" è§£ææ—¶å‘ç”Ÿé”™è¯¯:`, error.message);
                                console.error('è¯¦ç»†é”™è¯¯ä¿¡æ¯:', error);
                                continue; // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªå·¥ä½œè¡¨
                            }
                        }

                        if (!parseSuccess) {
                            alert('æ‰€æœ‰å·¥ä½œè¡¨éƒ½æœªæ‰¾åˆ°æœ‰æ•ˆçš„PADæ•°æ®ã€‚è¯·æ£€æŸ¥Excelæ–‡ä»¶æ ¼å¼ã€‚');
                            console.log('âŒ æ‰€æœ‰å·¥ä½œè¡¨è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥ä»¥ä¸‹å†…å®¹:');
                            console.log('1. æ˜¯å¦åŒ…å« "PAD Coordinates" æ ‡é¢˜');
                            console.log('2. æ˜¯å¦åŒ…å« "pad no", "x", "y" ç­‰åˆ—æ ‡é¢˜');
                            console.log('3. æ•°æ®æ ¼å¼æ˜¯å¦æ­£ç¡®');
                        }

                    } catch (error) {
                        alert('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message);
                        console.error('Excelæ–‡ä»¶è§£æé”™è¯¯:', error);
                    }
                };
                reader.readAsArrayBuffer(file);
            }

            parseExcelData(worksheet, sheetName = 'Sheet1') {
                // æ£€æŸ¥å·¥ä½œè¡¨æ˜¯å¦æœ‰æ•ˆ
                if (!worksheet || !worksheet['!ref']) {
                    console.log(`âš ï¸ å·¥ä½œè¡¨ "${sheetName}" ä¸ºç©ºæˆ–æ— æ•ˆï¼Œè·³è¿‡è§£æ`);
                    return false;
                }

                let range;
                try {
                    range = XLSX.utils.decode_range(worksheet['!ref']);
                } catch (error) {
                    console.log(`âŒ å·¥ä½œè¡¨ "${sheetName}" èŒƒå›´è§£æå¤±è´¥:`, error.message);
                    return false;
                }

                // åœ¨å°è¯•æ–°çš„å·¥ä½œè¡¨ä¹‹å‰ï¼Œä¸´æ—¶ä¿å­˜å½“å‰æ•°æ®
                const previousPads = [...this.pads];
                const previousWireConnections = [...this.wireConnections];
                const previousLFConnections = [...this.lfConnections];
                const previousTotalPinCount = this.totalPinCount;
                const previousChipSizeX = this.chipSizeX;
                const previousChipSizeY = this.chipSizeY;

                // é‡ç½®æ•°æ®ç”¨äºæ–°çš„è§£æå°è¯•
                this.pads = [];
                this.wireConnections = [];
                this.lfConnections = [];
                this.totalPinCount = 0;

                console.log(`ğŸ“Š å¼€å§‹è§£æå·¥ä½œè¡¨ "${sheetName}" (èŒƒå›´: ${range.s.r + 1}-${range.e.r + 1}è¡Œ, ${String.fromCharCode(65 + range.s.c)}-${String.fromCharCode(65 + range.e.c)}åˆ—)`);

                // é¦–å…ˆå°è¯•è§£æèŠ¯ç‰‡å°ºå¯¸
                this.parseChipSize(worksheet, range);

                // å°è¯•è§£æPADæ•°æ®ï¼Œå…ˆç”¨åŸé€»è¾‘ï¼Œå¤±è´¥åç”¨å¤‡ç”¨é€»è¾‘
                const padsParsed = this.parsePadDataPrimary(worksheet, range);
                if (!padsParsed) {
                    console.log('ä¸»è¦è§£ææ–¹æ³•å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨è§£ææ–¹æ³•');
                    this.parsePadDataFallback(worksheet, range);
                }

                // æ£€æŸ¥æ˜¯å¦æˆåŠŸè§£æåˆ°PADæ•°æ®
                const parseSuccess = this.pads.length > 0;

                if (parseSuccess) {
                    // è§£ææˆåŠŸï¼Œç»§ç»­å¤„ç†è¿çº¿å…³ç³»å’Œæ›´æ–°ç•Œé¢
                    console.log(`âœ… å·¥ä½œè¡¨ "${sheetName}" è§£ææˆåŠŸï¼Œæ‰¾åˆ° ${this.pads.length} ä¸ªPAD`);

                    // æŸ¥æ‰¾è¿çº¿å…³ç³»
                    this.parseWireConnections(worksheet, range);

                    this.updateStatistics();
                    this.updateDataPreview();
                    this.resetView();
                    this.draw();

                    return true;
                } else {
                    // è§£æå¤±è´¥ï¼Œæ¢å¤ä¹‹å‰çš„æ•°æ®
                    console.log(`âŒ å·¥ä½œè¡¨ "${sheetName}" è§£æå¤±è´¥ï¼Œæœªæ‰¾åˆ°æœ‰æ•ˆPADæ•°æ®`);
                    this.pads = previousPads;
                    this.wireConnections = previousWireConnections;
                    this.lfConnections = previousLFConnections;
                    this.totalPinCount = previousTotalPinCount;
                    this.chipSizeX = previousChipSizeX;
                    this.chipSizeY = previousChipSizeY;

                    return false;
                }
            }

            parseChipSize(worksheet, range) {
                let dieSizeFound = false;

                console.log('ğŸ” å¼€å§‹è§£æèŠ¯ç‰‡å°ºå¯¸...');

                // é¦–å…ˆå°è¯•æŸ¥æ‰¾"Die Size(um)"
                for (let R = range.s.r; R <= range.e.r && !dieSizeFound; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                        const cell = worksheet[cellAddress];
                        if (cell && cell.v && typeof cell.v !== 'undefined') {
                            const cellStr = cell.v.toString();
                            if (cellStr.includes('Die Size(um)')) {
                                // æŸ¥æ‰¾Båˆ—å’ŒDåˆ—çš„å€¼
                                const bCellAddress = XLSX.utils.encode_cell({ c: 1, r: R }); // Båˆ—
                                const dCellAddress = XLSX.utils.encode_cell({ c: 3, r: R }); // Dåˆ—
                                const bCell = worksheet[bCellAddress];
                                const dCell = worksheet[dCellAddress];

                                if (bCell && dCell) {
                                    this.chipSizeX = parseFloat(bCell.v) || 5000;
                                    this.chipSizeY = parseFloat(dCell.v) || 5000;
                                    document.getElementById('chipSizeX').value = this.chipSizeX;
                                    document.getElementById('chipSizeY').value = this.chipSizeY;
                                    dieSizeFound = true;
                                    console.log(`ä»Die Size(um)è§£æåˆ°èŠ¯ç‰‡å°ºå¯¸: ${this.chipSizeX} x ${this.chipSizeY}`);
                                }
                            }
                        }
                    }
                }

                // å¦‚æœæ²¡æ‰¾åˆ°Die Sizeï¼Œå°è¯•æŸ¥æ‰¾"chip size"
                if (!dieSizeFound) {
                    for (let R = range.s.r; R <= range.e.r && !dieSizeFound; ++R) {
                        for (let C = range.s.c; C <= range.e.c; ++C) {
                            const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                            const cell = worksheet[cellAddress];
                            if (cell && cell.v && typeof cell.v !== 'undefined') {
                                const cellStr = cell.v.toString().toLowerCase();
                                if (cellStr.includes('chip size') || cellStr.includes('die size')) {
                                    // æŸ¥æ‰¾è¯¥è¡Œä¸­çš„Xå’ŒYå€¼
                                    for (let nextC = C + 1; nextC <= Math.min(range.e.c, C + 10); ++nextC) {
                                        const xCellAddress = XLSX.utils.encode_cell({ c: nextC, r: R });
                                        const yCellAddress = XLSX.utils.encode_cell({ c: nextC + 1, r: R });
                                        const xCell = worksheet[xCellAddress];
                                        const yCell = worksheet[yCellAddress];

                                        if (xCell && yCell && !isNaN(xCell.v) && !isNaN(yCell.v)) {
                                            this.chipSizeX = parseFloat(xCell.v) || 5000;
                                            this.chipSizeY = parseFloat(yCell.v) || 5000;
                                            document.getElementById('chipSizeX').value = this.chipSizeX;
                                            document.getElementById('chipSizeY').value = this.chipSizeY;
                                            dieSizeFound = true;
                                            console.log(`ä»chip sizeè§£æåˆ°èŠ¯ç‰‡å°ºå¯¸: ${this.chipSizeX} x ${this.chipSizeY}`);
                                            break;
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        if (dieSizeFound) break;
                    }
                }

                if (!dieSizeFound) {
                    console.log(`âš ï¸ æœªæ‰¾åˆ°èŠ¯ç‰‡å°ºå¯¸ä¿¡æ¯ï¼Œä½¿ç”¨é»˜è®¤å€¼: ${this.chipSizeX} x ${this.chipSizeY}`);
                }
            }

            parsePadDataPrimary(worksheet, range) {
                console.log('ğŸ” æ–¹æ³•1: æŸ¥æ‰¾ "PAD Coordinates" æ ‡é¢˜...');

                // æŸ¥æ‰¾PAD Coordinates
                let padCoordinatesStartRow = -1;
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                        const cell = worksheet[cellAddress];
                        if (cell && cell.v && typeof cell.v !== 'undefined' && cell.v.toString().includes('PAD Coordinates')) {
                            padCoordinatesStartRow = R + 1; // ä¸‹ä¸€è¡Œå¼€å§‹æ˜¯æ•°æ®
                            console.log(`âœ… æ‰¾åˆ° "PAD Coordinates" æ ‡é¢˜åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—`);
                            break;
                        }
                    }
                    if (padCoordinatesStartRow !== -1) break;
                }

                if (padCoordinatesStartRow === -1) {
                    console.log('âŒ æœªæ‰¾åˆ° "PAD Coordinates" æ ‡é¢˜');
                }

                // è§£æPADæ•°æ® - åªè§£æAåˆ—æ˜¯æ•°å­—çš„è¡Œ
                if (padCoordinatesStartRow !== -1) {
                    console.log('ä½¿ç”¨ä¸»è¦è§£ææ–¹æ³• (PAD Coordinates)');
                    for (let R = padCoordinatesStartRow; R <= range.e.r; ++R) {
                        const aCellAddress = XLSX.utils.encode_cell({ c: 0, r: R }); // Aåˆ—
                        const aCell = worksheet[aCellAddress];

                        // å¤„ç†Aåˆ—çš„padç¼–å·ï¼Œæ”¯æŒæ–‡æœ¬æ ¼å¼çš„æ•°å­—
                        if (!aCell || !aCell.v) {
                            continue;
                        }

                        // å¤„ç†æ–‡æœ¬æ ¼å¼çš„æ•°å­—
                        const cellValue = aCell.v.toString().trim();
                        let padNumber;

                        if (typeof aCell.v === 'number' && Number.isInteger(aCell.v) && aCell.v > 0) {
                            // å¦‚æœæ˜¯æ•°å­—æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
                            padNumber = aCell.v;
                        } else {
                            // å¦‚æœæ˜¯æ–‡æœ¬æ ¼å¼ï¼Œæå–æ•°å­—
                            const extractedNumber = cellValue.replace(/[^\d]/g, '');
                            const numericValue = parseInt(extractedNumber);

                            if (!extractedNumber || isNaN(numericValue) || numericValue <= 0) {
                                console.log(`ä¸»è¦è§£æè·³è¿‡ç¬¬${R + 1}è¡Œï¼šAåˆ— "${cellValue}" æ— æ³•æå–æœ‰æ•ˆæ•°å­—`);
                                continue;
                            }

                            padNumber = numericValue;
                            console.log(`ä¸»è¦è§£æç¬¬${R + 1}è¡Œï¼šAåˆ— "${cellValue}" -> æå–æ•°å­— "${numericValue}"`);
                        }

                        const bCellAddress = XLSX.utils.encode_cell({ c: 1, r: R }); // Båˆ—
                        const cCellAddress = XLSX.utils.encode_cell({ c: 2, r: R }); // Cåˆ—
                        const dCellAddress = XLSX.utils.encode_cell({ c: 3, r: R }); // Dåˆ—
                        const eCellAddress = XLSX.utils.encode_cell({ c: 4, r: R }); // Eåˆ—

                        const bCell = worksheet[bCellAddress];
                        const cCell = worksheet[cCellAddress];
                        const dCell = worksheet[dCellAddress];
                        const eCell = worksheet[eCellAddress];

                        // ç¡®ä¿æœ‰åæ ‡æ•°æ®
                        if (cCell && dCell && !isNaN(cCell.v) && !isNaN(dCell.v)) {
                            try {
                                const padName = bCell && bCell.v ? bCell.v.toString().trim() : `PAD${padNumber}`;
                                const x = parseFloat(cCell.v);
                                const y = parseFloat(dCell.v);

                                // è§£æå°ºå¯¸
                                let width = 50, height = 50;
                                if (eCell && eCell.v) {
                                    const sizeStr = eCell.v.toString();
                                    // æ”¯æŒå¤šç§æ ¼å¼: (50 50), (50,50), 50 50, 50,50
                                    const sizeMatch = sizeStr.match(/\(?\s*([0-9.]+)[\s,]+([0-9.]+)\s*\)?/);
                                    if (sizeMatch) {
                                        width = parseFloat(sizeMatch[1]);
                                        height = parseFloat(sizeMatch[2]);
                                    }
                                }

                                this.pads.push({
                                    number: padNumber,
                                    x: x,
                                    y: y,
                                    width: width,
                                    height: height,
                                    name: padName
                                });
                            } catch (error) {
                                console.warn(`è§£æç¬¬${R + 1}è¡ŒPADæ•°æ®å¤±è´¥:`, error);
                            }
                        }
                    }
                    return true; // æˆåŠŸè§£æ
                }

                return false; // æœªæ‰¾åˆ°PAD Coordinates
            }

            parsePadDataFallback(worksheet, range) {
                console.log('ğŸ” æ–¹æ³•2: æŸ¥æ‰¾ "pad no" æ ‡é¢˜è¡Œ...');

                // æŸ¥æ‰¾"pad no"æ ‡é¢˜è¡Œ
                let padNoHeaderRow = -1;
                let padNoCol = -1;
                let padNameCol = -1;
                let xCol = -1;
                let yCol = -1;
                let padSizeCol = -1;

                // æ‰“å°å‰10è¡Œçš„å†…å®¹ç”¨äºè°ƒè¯•
                for (let R = range.s.r; R <= Math.min(range.e.r, range.s.r + 15); ++R) {
                    let rowContent = [];
                    for (let C = range.s.c; C <= Math.min(range.e.c, range.s.c + 10); ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                        const cell = worksheet[cellAddress];
                        const cellValue = cell && cell.v ? cell.v.toString() : '';
                        rowContent.push(`${String.fromCharCode(65 + C)}:${cellValue}`);
                    }
                    console.log(`ç¬¬${R + 1}è¡Œ: ${rowContent.join(' | ')}`);
                }

                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                        const cell = worksheet[cellAddress];
                        if (cell && cell.v && typeof cell.v !== 'undefined') {
                            const cellStr = cell.v.toString().toLowerCase().trim();
                            // æ‰©å±•pad noçš„æœç´¢æ¨¡å¼
                            if (cellStr.includes('pad no') || cellStr === 'pad no.' ||
                                cellStr.includes('pad number') || cellStr.includes('padnumber') ||
                                cellStr.includes('pad_no') || cellStr.includes('pad_number') ||
                                cellStr === 'no' || cellStr === 'number' || cellStr === 'padno') {
                                padNoHeaderRow = R;
                                padNoCol = C;
                                console.log(`æ‰¾åˆ°pad noæ ‡é¢˜åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—: "${cell.v}"`);
                                break;
                            }
                        }
                    }
                    if (padNoHeaderRow !== -1) break;
                }

                if (padNoHeaderRow === -1) {
                    console.log('å¤‡ç”¨è§£ææ–¹æ³•å¤±è´¥ï¼šæœªæ‰¾åˆ°pad noç›¸å…³æ ‡é¢˜');
                    console.log('è¯·æ£€æŸ¥Excelæ–‡ä»¶æ˜¯å¦åŒ…å«ä»¥ä¸‹ä»»ä¸€åˆ—æ ‡é¢˜:');
                    console.log('- pad no, pad number, pad_no, pad_number, padno, padnumber, no, number');
                    return false;
                }

                // åœ¨åŒä¸€è¡ŒæŸ¥æ‰¾å…¶ä»–åˆ—æ ‡é¢˜
                console.log(`åœ¨æ ‡é¢˜è¡Œ${padNoHeaderRow + 1}æŸ¥æ‰¾å…¶ä»–åˆ—æ ‡é¢˜...`);
                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const cellAddress = XLSX.utils.encode_cell({ c: C, r: padNoHeaderRow });
                    const cell = worksheet[cellAddress];
                    if (cell && cell.v && typeof cell.v !== 'undefined') {
                        const cellStr = cell.v.toString().toLowerCase().trim();
                        console.log(`æ£€æŸ¥ç¬¬${String.fromCharCode(65 + C)}åˆ—: "${cell.v}" -> "${cellStr}"`);

                        if (cellStr.includes('pad name') || cellStr.includes('name') ||
                            cellStr.includes('padname') || cellStr.includes('pad_name')) {
                            padNameCol = C;
                            console.log(`âœ“ æ‰¾åˆ°pad nameåˆ—åœ¨ç¬¬${String.fromCharCode(65 + C)}åˆ—: "${cell.v}"`);
                        } else if (cellStr === 'x' || cellStr.includes('x coord') ||
                            cellStr.includes('x_coord') || cellStr.includes('x-coord') ||
                            cellStr.includes('x position') || cellStr.includes('x pos') ||
                            cellStr.includes('coordinate x') || cellStr.includes('coord_x')) {
                            xCol = C;
                            console.log(`âœ“ æ‰¾åˆ°Xåæ ‡åˆ—åœ¨ç¬¬${String.fromCharCode(65 + C)}åˆ—: "${cell.v}"`);
                        } else if (cellStr === 'y' || cellStr.includes('y coord') ||
                            cellStr.includes('y_coord') || cellStr.includes('y-coord') ||
                            cellStr.includes('y position') || cellStr.includes('y pos') ||
                            cellStr.includes('coordinate y') || cellStr.includes('coord_y')) {
                            yCol = C;
                            console.log(`âœ“ æ‰¾åˆ°Yåæ ‡åˆ—åœ¨ç¬¬${String.fromCharCode(65 + C)}åˆ—: "${cell.v}"`);
                        } else if (cellStr.includes('pad size') || cellStr.includes('size') ||
                            cellStr.includes('padsize') || cellStr.includes('pad_size') ||
                            cellStr.includes('dimension') || cellStr.includes('width') ||
                            cellStr.includes('height')) {
                            padSizeCol = C;
                            console.log(`âœ“ æ‰¾åˆ°pad sizeåˆ—åœ¨ç¬¬${String.fromCharCode(65 + C)}åˆ—: "${cell.v}"`);
                        }
                    }
                }

                // æ£€æŸ¥å¿…è¦çš„åˆ—æ˜¯å¦éƒ½æ‰¾åˆ°äº†
                console.log(`åˆ—æ ‡é¢˜æŸ¥æ‰¾ç»“æœ:`);
                console.log(`- pad no: ${padNoCol >= 0 ? 'âœ“ ç¬¬' + String.fromCharCode(65 + padNoCol) + 'åˆ—' : 'âœ— æœªæ‰¾åˆ°'}`);
                console.log(`- pad name: ${padNameCol >= 0 ? 'âœ“ ç¬¬' + String.fromCharCode(65 + padNameCol) + 'åˆ—' : 'âœ— æœªæ‰¾åˆ°'}`);
                console.log(`- Xåæ ‡: ${xCol >= 0 ? 'âœ“ ç¬¬' + String.fromCharCode(65 + xCol) + 'åˆ—' : 'âœ— æœªæ‰¾åˆ°'}`);
                console.log(`- Yåæ ‡: ${yCol >= 0 ? 'âœ“ ç¬¬' + String.fromCharCode(65 + yCol) + 'åˆ—' : 'âœ— æœªæ‰¾åˆ°'}`);
                console.log(`- pad size: ${padSizeCol >= 0 ? 'âœ“ ç¬¬' + String.fromCharCode(65 + padSizeCol) + 'åˆ—' : 'âœ— æœªæ‰¾åˆ°'}`);

                if (padNoCol === -1 || xCol === -1 || yCol === -1) {
                    console.log('âŒ å¤‡ç”¨è§£ææ–¹æ³•å¤±è´¥ï¼šç¼ºå°‘å¿…è¦çš„åˆ—æ ‡é¢˜');
                    console.log('å¿…é¡»åˆ—: pad no, Xåæ ‡, Yåæ ‡');
                    console.log('è¯·ç¡®ä¿Excelæ–‡ä»¶åŒ…å«ä»¥ä¸‹åˆ—æ ‡é¢˜:');
                    console.log('Xåæ ‡åˆ—: x, x coord, x_coord, x-coord, x position, x pos, coordinate x, coord_x');
                    console.log('Yåæ ‡åˆ—: y, y coord, y_coord, y-coord, y position, y pos, coordinate y, coord_y');
                    return false;
                }

                console.log('âœ… ä½¿ç”¨å¤‡ç”¨è§£ææ–¹æ³• (pad noæ ‡é¢˜)');

                let successCount = 0;
                let errorCount = 0;

                // ä»æ ‡é¢˜è¡Œä¸‹ä¸€è¡Œå¼€å§‹è§£ææ•°æ®
                for (let R = padNoHeaderRow + 1; R <= range.e.r; ++R) {
                    const padNoCellAddress = XLSX.utils.encode_cell({ c: padNoCol, r: R });
                    const xCellAddress = XLSX.utils.encode_cell({ c: xCol, r: R });
                    const yCellAddress = XLSX.utils.encode_cell({ c: yCol, r: R });

                    const padNoCell = worksheet[padNoCellAddress];
                    const xCell = worksheet[xCellAddress];
                    const yCell = worksheet[yCellAddress];

                    // ç¡®ä¿æœ‰å¿…è¦çš„æ•°æ®ï¼Œå¹¶ä¸”pad noåˆ—åŒ…å«æ•°å­—
                    if (padNoCell && padNoCell.v && xCell && !isNaN(xCell.v) && yCell && !isNaN(yCell.v)) {
                        const padNoValue = padNoCell.v.toString().trim();

                        // å¤„ç†æ–‡æœ¬æ ¼å¼çš„æ•°å­—ï¼šæå–æ‰€æœ‰æ•°å­—å­—ç¬¦ï¼Œç„¶åéªŒè¯æ˜¯å¦èƒ½è½¬æ¢ä¸ºæœ‰æ•ˆæ•°å­—
                        const extractedNumber = padNoValue.replace(/[^\d]/g, ''); // æå–æ‰€æœ‰æ•°å­—å­—ç¬¦
                        const numericValue = parseInt(extractedNumber);

                        // åªå¤„ç†èƒ½æå–å‡ºæœ‰æ•ˆæ•°å­—çš„è¡Œï¼Œè·³è¿‡çº¯æ–‡æœ¬è¡Œæˆ–æ— æ•°å­—çš„è¡Œ
                        if (!extractedNumber || isNaN(numericValue) || numericValue <= 0) {
                            console.log(`è·³è¿‡ç¬¬${R + 1}è¡Œï¼špad no "${padNoValue}" æ— æ³•æå–æœ‰æ•ˆæ•°å­—`);
                            continue;
                        }

                        console.log(`ç¬¬${R + 1}è¡Œï¼špad no "${padNoValue}" -> æå–æ•°å­— "${numericValue}"`);

                        // ä½¿ç”¨æå–çš„æ•°å­—ä½œä¸ºpadç¼–å·
                        const finalPadNumber = numericValue;
                        try {
                            const x = parseFloat(xCell.v);
                            const y = parseFloat(yCell.v);

                            // è·å–pad nameï¼Œå¦‚æœæ²¡æœ‰nameåˆ—åˆ™ä½¿ç”¨åŸå§‹å€¼ä½œä¸ºåç§°
                            let padName = padNoValue; // é»˜è®¤ä½¿ç”¨åŸå§‹pad noå€¼ä½œä¸ºåç§°
                            if (padNameCol !== -1) {
                                const padNameCellAddress = XLSX.utils.encode_cell({ c: padNameCol, r: R });
                                const padNameCell = worksheet[padNameCellAddress];
                                if (padNameCell && padNameCell.v) {
                                    padName = padNameCell.v.toString().trim();
                                }
                            }

                            // è·å–pad size
                            let width = 50, height = 50;
                            if (padSizeCol !== -1) {
                                const padSizeCellAddress = XLSX.utils.encode_cell({ c: padSizeCol, r: R });
                                const padSizeCell = worksheet[padSizeCellAddress];
                                if (padSizeCell && padSizeCell.v) {
                                    const sizeStr = padSizeCell.v.toString();
                                    // æ”¯æŒå¤šç§æ ¼å¼: (50 50), (50,50), 50 50, 50,50, 50*50, 50x50
                                    const sizeMatch = sizeStr.match(/\(?\s*([0-9.]+)[\s,*xÃ—]+([0-9.]+)\s*\)?/);
                                    if (sizeMatch) {
                                        width = parseFloat(sizeMatch[1]);
                                        height = parseFloat(sizeMatch[2]);
                                    } else {
                                        // å¦‚æœæ˜¯å•ä¸ªæ•°å­—ï¼Œè®¤ä¸ºæ˜¯æ­£æ–¹å½¢
                                        const singleSize = parseFloat(sizeStr);
                                        if (!isNaN(singleSize)) {
                                            width = height = singleSize;
                                        }
                                    }
                                }
                            }

                            this.pads.push({
                                number: finalPadNumber, // ä½¿ç”¨æå–çš„æ•°å­—ä½œä¸ºç¼–å·
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                name: padName
                            });
                            successCount++;
                        } catch (error) {
                            console.warn(`å¤‡ç”¨è§£æç¬¬${R + 1}è¡ŒPADæ•°æ®å¤±è´¥:`, error);
                            errorCount++;
                        }
                    }
                }

                console.log(`ğŸ“Š å¤‡ç”¨è§£æå®Œæˆç»Ÿè®¡:`);
                console.log(`- æˆåŠŸè§£æ: ${successCount} ä¸ªPAD`);
                console.log(`- è§£æé”™è¯¯: ${errorCount} ä¸ªPAD`);
                console.log(`- æ€»è®¡: ${this.pads.length} ä¸ªPADå·²æ·»åŠ åˆ°æ•°ç»„`);

                return true;
            }

            parseWireConnections(worksheet, range) {
                this.wireConnections = [];
                this.lfConnections = []; // æ–°å¢ï¼šå­˜å‚¨L/Fè¿çº¿
                this.totalPinCount = 0; // æ–°å¢ï¼šå­˜å‚¨æ€»PINæ•°é‡

                // æŸ¥æ‰¾PIN Configurationæ ‡é¢˜
                let pinConfigurationStartRow = -1;
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                        const cell = worksheet[cellAddress];
                        if (cell && cell.v && typeof cell.v !== 'undefined') {
                            const cellStr = cell.v.toString().toLowerCase();
                            if (cellStr.includes('pin configuration') || cellStr.includes('pin config')) {
                                pinConfigurationStartRow = R + 1;
                                console.log(`æ‰¾åˆ°PIN Configurationåœ¨ç¬¬${R + 1}è¡Œ: ${cell.v}`);
                                break;
                            }
                        }
                    }
                    if (pinConfigurationStartRow !== -1) break;
                }

                if (pinConfigurationStartRow === -1) {
                    console.log('æœªæ‰¾åˆ°PIN Configurationæ ‡é¢˜ï¼Œä½¿ç”¨åŸæœ‰é€»è¾‘æŸ¥æ‰¾è¿çº¿å…³ç³»');
                    // å¦‚æœæ²¡æ‰¾åˆ°PIN Configurationï¼Œå›é€€åˆ°åŸæœ‰é€»è¾‘
                    this.parseFallbackWireConnections(worksheet, range);
                    return;
                }

                // æŸ¥æ‰¾è¡¨å¤´è¡Œï¼Œå¯»æ‰¾PIN Numberã€PAD numberã€pad to L/Fã€pin to L/Få’ŒPAD to PADåˆ—
                let headerRow = -1;
                let pinNumberCol = -1;
                let padNumberCol = -1;
                let padToLFCol = -1;
                let pinToLFCol = -1;
                let padToPadCol = -1;

                // ä»PIN Configurationæ ‡é¢˜å¼€å§‹å‘ä¸‹æŸ¥æ‰¾è¡¨å¤´
                for (let R = pinConfigurationStartRow; R <= Math.min(range.e.r, pinConfigurationStartRow + 10); ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                        const cell = worksheet[cellAddress];
                        if (cell && cell.v && typeof cell.v !== 'undefined') {
                            const cellStr = cell.v.toString().toLowerCase().trim();
                            if (cellStr.includes('pin number') || cellStr === 'pin') {
                                headerRow = R;
                                pinNumberCol = C;
                                console.log(`æ‰¾åˆ°PIN Numberåˆ—åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—`);
                            }
                            if (cellStr.includes('pad number') || cellStr === 'pad') {
                                padNumberCol = C;
                                console.log(`æ‰¾åˆ°PAD numberåˆ—åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—`);
                            }
                            if (cellStr.includes('pad to l/f') || cellStr.includes('pad to lf')) {
                                padToLFCol = C;
                                console.log(`æ‰¾åˆ°pad to L/Fåˆ—åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—`);
                            }
                            if (cellStr.includes('pin to l/f') || cellStr.includes('pin to lf')) {
                                pinToLFCol = C;
                                console.log(`æ‰¾åˆ°pin to L/Fåˆ—åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—`);
                            }
                            if (cellStr.includes('pad to pad')) {
                                padToPadCol = C;
                                console.log(`æ‰¾åˆ°PAD to PADåˆ—åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—`);
                            }
                        }
                    }
                    // å¦‚æœæ‰¾åˆ°äº†PINå’ŒPADåˆ—ï¼Œé€€å‡ºå¾ªç¯
                    if (pinNumberCol !== -1 && padNumberCol !== -1) {
                        break;
                    }
                }

                if (headerRow === -1 || pinNumberCol === -1 || padNumberCol === -1) {
                    console.log('æœªæ‰¾åˆ°å®Œæ•´çš„PIN Numberå’ŒPAD numberè¡¨å¤´ï¼Œä½¿ç”¨åŸæœ‰é€»è¾‘');
                    this.parseFallbackWireConnections(worksheet, range);
                    return;
                }

                // ä»è¡¨å¤´ä¸‹ä¸€è¡Œå¼€å§‹è§£ææ•°æ®
                let maxPinNumber = 0; // è®°å½•æœ€å¤§çš„PINç¼–å·
                for (let R = headerRow + 1; R <= range.e.r; ++R) {
                    const pinCellAddress = XLSX.utils.encode_cell({ c: pinNumberCol, r: R });
                    const padCellAddress = XLSX.utils.encode_cell({ c: padNumberCol, r: R });

                    const pinCell = worksheet[pinCellAddress];
                    const padCell = worksheet[padCellAddress];

                    // è§£æå¸¸è§„PIN-PADè¿çº¿
                    if (pinCell && padCell && pinCell.v && padCell.v) {
                        const pinVal = pinCell.v.toString().trim();
                        let padVal = padCell.v.toString().trim();

                        // ç¡®ä¿PINæ˜¯æ•°å­—
                        if (pinVal.match(/^\d+$/)) {
                            const pinNum = parseInt(pinVal);
                            if (pinNum > maxPinNumber) {
                                maxPinNumber = pinNum;
                            }

                            // å¤„ç†PADç¼–å·ï¼šå¦‚æœæ˜¯å¤§äº1000çš„æ•°å­—ï¼Œå¯èƒ½æ˜¯åƒä½åˆ†éš”ç¬¦è¢«è¯†åˆ«äº†
                            let padNumbers = [];
                            if (/^\d+$/.test(padVal)) {
                                const padNum = parseInt(padVal);
                                if (padNum >= 1000) {
                                    // ä»åå¾€å‰æ¯3ä½åˆ†å‰²
                                    const padStr = padVal;
                                    const parts = [];
                                    for (let i = padStr.length; i > 0; i -= 3) {
                                        const start = Math.max(0, i - 3);
                                        parts.unshift(padStr.substring(start, i));
                                    }
                                    padNumbers = parts;
                                    console.log(`PAD number ${padVal} è¢«æ‹†åˆ†ä¸º: ${parts.join(', ')}`);
                                } else {
                                    padNumbers = [padVal];
                                }
                            } else {
                                // å¤„ç†å¯èƒ½çš„å¤šä¸ªPADç¼–å·ï¼ˆç”¨ã€ï¼Œã€ï¼›åˆ†éš”ï¼‰
                                padNumbers = padVal.split(/[,ï¼Œã€;ï¼›]/).map(pad => pad.trim()).filter(pad => pad);
                            }

                            padNumbers.forEach(padNumber => {
                                this.wireConnections.push({
                                    pin: `p${pinVal}`,  // æ·»åŠ på‰ç¼€ä»¥åŒ¹é…LSPè„šæœ¬æ ¼å¼
                                    pad: padNumber.toString()  // ç¡®ä¿æ˜¯å­—ç¬¦ä¸²
                                });
                            });
                        }
                    }

                    // è§£æpad to L/Fè¿çº¿
                    if (padToLFCol !== -1) {
                        const padToLFCellAddress = XLSX.utils.encode_cell({ c: padToLFCol, r: R });
                        const padToLFCell = worksheet[padToLFCellAddress];

                        if (padToLFCell && padToLFCell.v && padToLFCell.v.toString().trim()) {
                            // è·å–Eåˆ—çš„PAD number
                            const eCellAddress = XLSX.utils.encode_cell({ c: 4, r: R }); // Eåˆ—æ˜¯ç¬¬4åˆ—ï¼ˆä»0å¼€å§‹ï¼‰
                            const eCell = worksheet[eCellAddress];

                            if (eCell && eCell.v) {
                                let padNumbersStr = eCell.v.toString().trim();
                                let padNumbers = [];

                                // å¤„ç†PADç¼–å·ï¼šå¦‚æœæ˜¯å¤§äº1000çš„æ•°å­—ï¼Œå¯èƒ½æ˜¯åƒä½åˆ†éš”ç¬¦è¢«è¯†åˆ«äº†
                                if (/^\d+$/.test(padNumbersStr)) {
                                    const padNum = parseInt(padNumbersStr);
                                    if (padNum >= 1000) {
                                        // ä»åå¾€å‰æ¯3ä½åˆ†å‰²
                                        const parts = [];
                                        for (let i = padNumbersStr.length; i > 0; i -= 3) {
                                            const start = Math.max(0, i - 3);
                                            parts.unshift(padNumbersStr.substring(start, i));
                                        }
                                        padNumbers = parts;
                                        console.log(`pad to L/F: PAD number ${padNumbersStr} è¢«æ‹†åˆ†ä¸º: ${parts.join(', ')}`);
                                    } else {
                                        padNumbers = [padNumbersStr];
                                    }
                                } else {
                                    // å¤„ç†å¯èƒ½çš„å¤šä¸ªPADç¼–å·ï¼ˆç”¨,ï¼Œã€;ï¼›ç­‰åˆ†éš”ï¼‰
                                    padNumbers = padNumbersStr.split(/[,ï¼Œã€;ï¼›\s]+/).map(pad => pad.trim()).filter(pad => pad);
                                }

                                padNumbers.forEach(padNumber => {
                                    this.lfConnections.push({
                                        type: 'pad',
                                        number: padNumber
                                    });
                                    console.log(`æ‰¾åˆ°pad to L/F: PAD ${padNumber}`);
                                });
                            }
                        }
                    }

                    // è§£æpin to L/Fè¿çº¿
                    if (pinToLFCol !== -1) {
                        const pinToLFCellAddress = XLSX.utils.encode_cell({ c: pinToLFCol, r: R });
                        const pinToLFCell = worksheet[pinToLFCellAddress];

                        if (pinToLFCell && pinToLFCell.v && pinToLFCell.v.toString().trim()) {
                            // è·å–Aåˆ—çš„PIN number
                            const aCellAddress = XLSX.utils.encode_cell({ c: 0, r: R }); // Aåˆ—æ˜¯ç¬¬0åˆ—
                            const aCell = worksheet[aCellAddress];

                            if (aCell && aCell.v) {
                                const pinNumber = aCell.v.toString().trim();
                                this.lfConnections.push({
                                    type: 'pin',
                                    number: pinNumber
                                });
                                console.log(`æ‰¾åˆ°pin to L/F: PIN ${pinNumber}`);
                            }
                        }
                    }

                    // è§£æPAD to PADè¿çº¿
                    if (padToPadCol !== -1) {
                        const padToPadCellAddress = XLSX.utils.encode_cell({ c: padToPadCol, r: R });
                        const padToPadCell = worksheet[padToPadCellAddress];

                        if (padToPadCell && padToPadCell.v && padToPadCell.v.toString().trim()) {
                            const padToPadValue = padToPadCell.v.toString().trim();
                            const padCellAddress = XLSX.utils.encode_cell({ c: padNumberCol, r: R });
                            const padCell = worksheet[padCellAddress];

                            if (padCell && padCell.v) {
                                const pad1Number = padCell.v.toString().trim();

                                // åˆ¤æ–­æ˜¯çº¯æ•°å­—è¿˜æ˜¯åŒ…å«æ–‡å­—
                                if (/^\d+$/.test(padToPadValue)) {
                                    // çº¯æ•°å­—ï¼šdie1å†…éƒ¨çš„pad to padè¿çº¿
                                    this.padToPadConnections.push({
                                        type: 'die1-to-die1',
                                        pad1: pad1Number,
                                        pad2: padToPadValue
                                    });
                                    console.log(`æ‰¾åˆ°die1 PAD to PAD: ${pad1Number} â†’ ${padToPadValue}`);
                                } else {
                                    // åŒ…å«æ–‡å­—ï¼šdie1å’Œdie2ä¹‹é—´çš„è¿çº¿
                                    // ç›´æ¥ä½¿ç”¨æ•´ä¸ªæ–‡æœ¬ä½œä¸ºæœç´¢å…³é”®è¯
                                    this.padToPadConnections.push({
                                        type: 'die1-to-die2',
                                        pad1: pad1Number,
                                        d2SearchText: padToPadValue,
                                        originalText: padToPadValue
                                    });
                                    console.log(`æ‰¾åˆ°die1-die2 PAD to PAD: ${pad1Number} â†’ D2[${padToPadValue}]`);
                                }
                            }
                        }
                    }
                }

                this.totalPinCount = maxPinNumber;
                console.log(`ä»PIN Configurationè§£æåˆ° ${this.wireConnections.length} ä¸ªè¿çº¿å…³ç³»`);
                console.log(`ä»PIN Configurationè§£æåˆ° ${this.lfConnections.length} ä¸ªL/Fè¿çº¿`);
                console.log(`ä»PIN Configurationè§£æåˆ° ${this.padToPadConnections.length} ä¸ªPAD to PADè¿çº¿`);
                console.log(`æ€»PINæ•°é‡: ${this.totalPinCount}`);
                if (this.wireConnections.length > 0) {
                    console.log('å‰å‡ ä¸ªè¿çº¿å…³ç³»:', this.wireConnections.slice(0, 5));
                }
                if (this.lfConnections.length > 0) {
                    console.log('L/Fè¿çº¿:', this.lfConnections);
                }
                if (this.padToPadConnections.length > 0) {
                    console.log('PAD to PADè¿çº¿:', this.padToPadConnections);
                }
            }

            // å›é€€é€»è¾‘ï¼šå¦‚æœæ²¡æ‰¾åˆ°PIN Configurationï¼Œä½¿ç”¨åŸæœ‰æ–¹æ³•
            parseFallbackWireConnections(worksheet, range) {
                // åœ¨æ•´ä¸ªè¡¨æ ¼ä¸­æŸ¥æ‰¾å¯èƒ½çš„PIN-PADè¿æ¥
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    const aCellAddress = XLSX.utils.encode_cell({ c: 0, r: R }); // Aåˆ—
                    const bCellAddress = XLSX.utils.encode_cell({ c: 1, r: R }); // Båˆ—

                    const aCell = worksheet[aCellAddress];
                    const bCell = worksheet[bCellAddress];

                    if (aCell && bCell && aCell.v && bCell.v) {
                        const aVal = aCell.v.toString().trim();
                        const bVal = bCell.v.toString().trim();

                        // æ£€æŸ¥æ˜¯å¦ä¸ºPINç¼–å·ï¼ˆçº¯æ•°å­—ï¼‰å’ŒPADç¼–å·çš„ç»„åˆ
                        // å¹¶ä¸”è¦æ’é™¤PADåæ ‡æ•°æ®åŒºåŸŸ
                        if (aVal.match(/^\d+$/) && bVal.length > 0 &&
                            !bVal.match(/^(X|Y|åæ ‡|åç§°|ç¼–å·|pad|coordinates)/i) &&
                            !bVal.match(/^\d+(\.\d+)?$/)) { // æ’é™¤çº¯æ•°å­—ï¼ˆå¯èƒ½æ˜¯åæ ‡ï¼‰

                            // æ£€æŸ¥Båˆ—å³ä¾§æ˜¯å¦æœ‰æ•°å­—åæ ‡ï¼ˆå¦‚æœæœ‰ï¼Œåˆ™å¯èƒ½æ˜¯PADæ•°æ®è€Œä¸æ˜¯è¿çº¿æ•°æ®ï¼‰
                            const cCellAddress = XLSX.utils.encode_cell({ c: 2, r: R });
                            const dCellAddress = XLSX.utils.encode_cell({ c: 3, r: R });
                            const cCell = worksheet[cCellAddress];
                            const dCell = worksheet[dCellAddress];

                            const hasCoordinates = cCell && dCell &&
                                !isNaN(cCell.v) && !isNaN(dCell.v) &&
                                cCell.v !== '' && dCell.v !== '';

                            // å¦‚æœæ²¡æœ‰åæ ‡æ•°æ®ï¼Œåˆ™è®¤ä¸ºæ˜¯è¿çº¿å…³ç³»
                            if (!hasCoordinates) {
                                // å¤„ç†å¯èƒ½çš„å¤šä¸ªPADç¼–å·ï¼ˆç”¨ã€ï¼Œã€ï¼›åˆ†éš”ï¼‰
                                const padNumbers = bVal.split(/[,ï¼Œã€;ï¼›]/).map(pad => pad.trim()).filter(pad => pad);

                                padNumbers.forEach(padNumber => {
                                    this.wireConnections.push({
                                        pin: `p${aVal}`,  // æ·»åŠ på‰ç¼€ä»¥åŒ¹é…LSPè„šæœ¬æ ¼å¼
                                        pad: padNumber    // å­˜å‚¨padç¼–å·
                                    });
                                });
                            }
                        }
                    }
                }
            }

            parseD2ChipData(worksheet) {
                console.log('ğŸ” å¼€å§‹è§£æD2èŠ¯ç‰‡æ•°æ®...');

                if (!worksheet || !worksheet['!ref']) {
                    console.log('âš ï¸ D2å·¥ä½œè¡¨ä¸ºç©ºæˆ–æ— æ•ˆ');
                    return;
                }

                const range = XLSX.utils.decode_range(worksheet['!ref']);
                console.log(`ğŸ“Š D2å·¥ä½œè¡¨èŒƒå›´: ${range.s.r + 1}-${range.e.r + 1}è¡Œ, ${String.fromCharCode(65 + range.s.c)}-${String.fromCharCode(65 + range.e.c)}åˆ—`);
                this.d2Pads = [];

                // è§£æDie Size
                console.log('ğŸ” å¼€å§‹æŸ¥æ‰¾D2 Die Size...');
                for (let R = range.s.r; R <= range.e.r; ++R) {
                    for (let C = range.s.c; C <= range.e.c; ++C) {
                        const cellAddress = XLSX.utils.encode_cell({ c: C, r: R });
                        const cell = worksheet[cellAddress];
                        if (cell && cell.v && typeof cell.v !== 'undefined') {
                            const cellStr = cell.v.toString().toLowerCase();
                            if (cellStr.includes('die size')) {
                                console.log(`æ‰¾åˆ°"Die Size"åœ¨ç¬¬${R + 1}è¡Œç¬¬${String.fromCharCode(65 + C)}åˆ—: "${cell.v}"`);

                                // å…ˆå°è¯•è¯»å–åé¢ä¸€ä¸ªå•å…ƒæ ¼ï¼Œå¦‚æœæ˜¯ç©ºçš„ï¼Œè¯´æ˜æœ‰åˆå¹¶å•å…ƒæ ¼
                                let xCol = C + 1;
                                let yCol = C + 2;

                                const nextCellAddress = XLSX.utils.encode_cell({ c: C + 1, r: R });
                                const nextCell = worksheet[nextCellAddress];

                                // å¦‚æœBåˆ—æ˜¯ç©ºçš„ï¼ˆåˆå¹¶å•å…ƒæ ¼ï¼‰ï¼Œå¾€åç§»ä¸¤åˆ—ï¼ˆCå’ŒDåˆ—ï¼‰
                                if (!nextCell || !nextCell.v) {
                                    console.log(`${String.fromCharCode(65 + C + 1)}åˆ—ä¸ºç©ºï¼ˆåˆå¹¶å•å…ƒæ ¼ï¼‰ï¼Œå¾€åæŸ¥æ‰¾Cå’ŒDåˆ—`);
                                    xCol = C + 2;
                                    yCol = C + 3;
                                }

                                const xCellAddress = XLSX.utils.encode_cell({ c: xCol, r: R });
                                const yCellAddress = XLSX.utils.encode_cell({ c: yCol, r: R });
                                const xCell = worksheet[xCellAddress];
                                const yCell = worksheet[yCellAddress];

                                console.log(`å°è¯•è¯»å–å°ºå¯¸: ${String.fromCharCode(65 + xCol)}${R + 1}=${xCell ? xCell.v : 'null'}, ${String.fromCharCode(65 + yCol)}${R + 1}=${yCell ? yCell.v : 'null'}`);

                                if (xCell && yCell && !isNaN(xCell.v) && !isNaN(yCell.v)) {
                                    this.d2ChipSizeX = parseFloat(xCell.v);
                                    this.d2ChipSizeY = parseFloat(yCell.v);
                                    console.log(`âœ… D2èŠ¯ç‰‡å°ºå¯¸: ${this.d2ChipSizeX} x ${this.d2ChipSizeY}`);
                                    break;
                                } else {
                                    console.log('âš ï¸ Die Sizeåé¢çš„å•å…ƒæ ¼ä¸æ˜¯æœ‰æ•ˆæ•°å­—');
                                }
                            }
                        }
                    }
                    if (this.d2ChipSizeX > 0) break;
                }

                if (this.d2ChipSizeX === 0 || this.d2ChipSizeY === 0) {
                    console.log('âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆçš„D2 Die Sizeï¼Œä½¿ç”¨é»˜è®¤å€¼ 1000 x 1000');
                    this.d2ChipSizeX = 1000;
                    this.d2ChipSizeY = 1000;
                }

                // ç›´æ¥ä»ç¬¬2è¡Œå¼€å§‹è§£æï¼ˆç¬¬1è¡Œæ˜¯è¡¨å¤´ï¼‰
                // åˆ—æ ¼å¼ï¼šA=Pad No, B=Pad Name, C=X, D=Y, E=Pad Size
                console.log(`ğŸ“‹ å¼€å§‹ä»ç¬¬2è¡Œè§£æD2 PADæ•°æ®ï¼ˆè·³è¿‡è¡¨å¤´ï¼‰...`);

                let parsedCount = 0;
                for (let R = 1; R <= range.e.r; ++R) { // ä»ç¬¬2è¡Œå¼€å§‹ï¼ˆç´¢å¼•1ï¼‰
                    const aCellAddress = XLSX.utils.encode_cell({ c: 0, r: R }); // Aåˆ—: Pad No
                    const bCellAddress = XLSX.utils.encode_cell({ c: 1, r: R }); // Båˆ—: Pad Name
                    const cCellAddress = XLSX.utils.encode_cell({ c: 2, r: R }); // Cåˆ—: X
                    const dCellAddress = XLSX.utils.encode_cell({ c: 3, r: R }); // Dåˆ—: Y
                    const eCellAddress = XLSX.utils.encode_cell({ c: 4, r: R }); // Eåˆ—: Pad Size

                    const aCell = worksheet[aCellAddress];
                    const bCell = worksheet[bCellAddress];
                    const cCell = worksheet[cCellAddress];
                    const dCell = worksheet[dCellAddress];
                    const eCell = worksheet[eCellAddress];

                    // è·³è¿‡è¡¨å¤´è¡Œ
                    if (!aCell || !aCell.v) {
                        // å¦‚æœAåˆ—ä¸ºç©ºä¸”å·²ç»å¼€å§‹è§£æPADï¼Œè¯´æ˜PADæ•°æ®ç»“æŸ
                        if (parsedCount > 0) {
                            console.log(`é‡åˆ°ç©ºè¡Œï¼Œåœæ­¢è§£æï¼ˆç¬¬${R + 1}è¡Œï¼‰`);
                            break;
                        }
                        continue;
                    }

                    const aCellValue = aCell.v.toString().trim();

                    // è·³è¿‡è¡¨å¤´ï¼ˆåŒ…å«"pad"ã€"no"ç­‰æ–‡å­—ï¼‰
                    if (aCellValue.toLowerCase().includes('pad') || aCellValue.toLowerCase().includes('no')) {
                        continue;
                    }

                    // æ£€æŸ¥Aåˆ—æ˜¯å¦ä¸ºçº¯æ•°å­—
                    if (!/^\d+$/.test(aCellValue)) {
                        // å¦‚æœä¸æ˜¯çº¯æ•°å­—ä¸”å·²ç»å¼€å§‹è§£æPADï¼Œè¯´æ˜PADæ•°æ®ç»“æŸ
                        if (parsedCount > 0) {
                            console.log(`é‡åˆ°éæ•°å­—å•å…ƒæ ¼"${aCellValue}"ï¼Œåœæ­¢è§£æï¼ˆç¬¬${R + 1}è¡Œï¼‰`);
                            break;
                        }
                        continue;
                    }

                    // ç¡®ä¿æœ‰åæ ‡æ•°æ®
                    if (cCell && dCell && !isNaN(cCell.v) && !isNaN(dCell.v)) {
                        try {
                            const padNumber = aCell.v.toString().trim();
                            let padName = bCell && bCell.v ? bCell.v.toString().trim() : `PAD${padNumber}`;

                            // å»æ‰pad nameåé¢çš„å†’å·
                            padName = padName.replace(/:$/, '');

                            const x = parseFloat(cCell.v);
                            const y = parseFloat(dCell.v);

                            // è§£æå°ºå¯¸
                            let width = 50, height = 50;
                            if (eCell && eCell.v) {
                                const sizeStr = eCell.v.toString();
                                const sizeMatch = sizeStr.match(/([0-9.]+)\s*[*Ã—xX]\s*([0-9.]+)/);
                                if (sizeMatch) {
                                    width = parseFloat(sizeMatch[1]);
                                    height = parseFloat(sizeMatch[2]);
                                }
                            }

                            this.d2Pads.push({
                                number: padNumber,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                name: padName
                            });
                            parsedCount++;

                            if (parsedCount <= 3) {
                                console.log(`D2 PAD ${padNumber}: ${padName} at (${x}, ${y}), size: ${width}x${height}`);
                            }
                        } catch (error) {
                            console.warn(`è§£æD2ç¬¬${R + 1}è¡ŒPADæ•°æ®å¤±è´¥:`, error);
                        }
                    }
                }

                console.log(`âœ… D2èŠ¯ç‰‡è§£æå®Œæˆï¼Œæ‰¾åˆ° ${this.d2Pads.length} ä¸ªPAD`);
                if (this.d2Pads.length === 0) {
                    console.log('âš ï¸ è­¦å‘Šï¼šD2èŠ¯ç‰‡æ²¡æœ‰è§£æåˆ°ä»»ä½•PADæ•°æ®');
                    console.log(`èŠ¯ç‰‡å°ºå¯¸: ${this.d2ChipSizeX} x ${this.d2ChipSizeY}`);
                }
            }

            updateStatistics() {
                const totalPads = this.pads.length;
                const vssPads = this.pads.filter(pad =>
                    pad.name.toUpperCase().includes('VSS') ||
                    pad.name.toUpperCase().includes('VREFN')
                ).length;
                const vddPads = this.pads.filter(pad =>
                    pad.name.toUpperCase().includes('VDD') ||
                    pad.name.toUpperCase().includes('VREFP')
                ).length;
                const totalWires = this.wireConnections.length;
                const totalLFWires = this.lfConnections ? this.lfConnections.length : 0;

                document.getElementById('padCount').textContent = `PADæ•°é‡: ${totalPads}`;
                document.getElementById('vssCount').textContent = `VSS PAD: ${vssPads}`;
                document.getElementById('vddCount').textContent = `VDD PAD: ${vddPads}`;
                document.getElementById('wireCount').textContent = `è¿çº¿æ•°é‡: ${totalWires}`;
                document.getElementById('lfCount').textContent = `L/Fè¿çº¿: ${totalLFWires}`;
            }

            updateDataPreview() {
                const dataPreview = document.getElementById('dataPreview');
                const padPreviewTable = document.getElementById('padPreviewTable');
                const wirePreviewTable = document.getElementById('wirePreviewTable');

                // æ›´æ–°PADé¢„è§ˆ
                padPreviewTable.innerHTML = '';
                this.pads.slice(0, 10).forEach(pad => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="px-2 py-1">${pad.number}</td>
                        <td class="px-2 py-1">${pad.x}</td>
                        <td class="px-2 py-1">${pad.y}</td>
                        <td class="px-2 py-1">${pad.width}Ã—${pad.height}</td>
                    `;
                    padPreviewTable.appendChild(row);
                });

                // æ›´æ–°è¿çº¿é¢„è§ˆ
                wirePreviewTable.innerHTML = '';
                this.wireConnections.slice(0, 10).forEach(conn => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="px-2 py-1">${conn.pin}</td>
                        <td class="px-2 py-1">${conn.pad}</td>
                    `;
                    wirePreviewTable.appendChild(row);
                });

                dataPreview.style.display = 'block';
            }

            resetView() {
                this.scale = Math.min(
                    (this.canvas.width - 100) / this.chipSizeX,
                    (this.canvas.height - 100) / this.chipSizeY
                );
                this.offsetX = 50;
                this.offsetY = this.canvas.height - 50;
                this.draw();
            }

            worldToScreen(x, y) {
                return {
                    x: this.offsetX + x * this.scale,
                    y: this.offsetY - y * this.scale
                };
            }

            screenToWorld(x, y) {
                return {
                    x: (x - this.offsetX) / this.scale,
                    y: (this.offsetY - y) / this.scale
                };
            }

            getPadColor(padName) {
                const name = padName.toUpperCase();
                if (name.includes('VSS') || name.includes('VREFN')) {
                    return '#10B981'; // ç»¿è‰²
                } else if (name.includes('VDD') || name.includes('VREFP')) {
                    return '#F59E0B'; // é»„è‰²
                } else {
                    return '#6B7280'; // ç°è‰²
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // ç»˜åˆ¶èŠ¯ç‰‡è½®å»“
                this.drawChipOutline();

                // ç»˜åˆ¶PAD
                this.pads.forEach(pad => {
                    this.drawPad(pad);
                });

                // ç»˜åˆ¶åæ ‡è½´
                this.drawAxes();
            }

            drawChipOutline() {
                const topLeft = this.worldToScreen(0, this.chipSizeY);
                const bottomRight = this.worldToScreen(this.chipSizeX, 0);

                this.ctx.strokeStyle = '#374151';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(
                    topLeft.x,
                    topLeft.y,
                    bottomRight.x - topLeft.x,
                    bottomRight.y - topLeft.y
                );

                // æ·»åŠ èŠ¯ç‰‡æ ‡ç­¾
                this.ctx.fillStyle = '#374151';
                this.ctx.font = '14px Arial';
                this.ctx.fillText(
                    `èŠ¯ç‰‡ (${this.chipSizeX} Ã— ${this.chipSizeY} Î¼m)`,
                    topLeft.x + 10,
                    topLeft.y + 20
                );
            }

            drawPad(pad) {
                const center = this.worldToScreen(pad.x, pad.y);
                const width = pad.width * this.scale;
                const height = pad.height * this.scale;

                // ç»˜åˆ¶PADçŸ©å½¢
                this.ctx.fillStyle = this.getPadColor(pad.name);
                this.ctx.fillRect(
                    center.x - width / 2,
                    center.y - height / 2,
                    width,
                    height
                );

                // ç»˜åˆ¶PADè¾¹æ¡†
                this.ctx.strokeStyle = '#1F2937';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(
                    center.x - width / 2,
                    center.y - height / 2,
                    width,
                    height
                );

                // ç»˜åˆ¶PADç¼–å·
                this.ctx.save();
                this.ctx.fillStyle = '#FFFFFF';
                let fontSize = Math.min(width, height) * 0.7;
                if (fontSize < 6) fontSize = 6;
                this.ctx.font = `bold ${fontSize}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                let text = pad.number.toString();
                let metrics = this.ctx.measureText(text);
                while ((metrics.width > width * 0.9 || fontSize > height * 0.9) && fontSize > 6) {
                    fontSize -= 1;
                    this.ctx.font = `bold ${fontSize}px Arial`;
                    metrics = this.ctx.measureText(text);
                }
                this.ctx.fillText(text, center.x, center.y);
                this.ctx.restore();
            }

            drawAxes() {
                // Xè½´
                const xStart = this.worldToScreen(0, 0);
                const xEnd = this.worldToScreen(this.chipSizeX, 0);

                this.ctx.strokeStyle = '#9CA3AF';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(xStart.x, xStart.y);
                this.ctx.lineTo(xEnd.x, xEnd.y);
                this.ctx.stroke();

                // Yè½´
                const yStart = this.worldToScreen(0, 0);
                const yEnd = this.worldToScreen(0, this.chipSizeY);

                this.ctx.beginPath();
                this.ctx.moveTo(yStart.x, yStart.y);
                this.ctx.lineTo(yEnd.x, yEnd.y);
                this.ctx.stroke();

                // åæ ‡æ ‡ç­¾
                this.ctx.fillStyle = '#6B7280';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('(0,0)', xStart.x + 5, xStart.y - 5);
            }

            handleMouseDown(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.lastMouseX = event.clientX - rect.left;
                this.lastMouseY = event.clientY - rect.top;
                this.isDragging = true;
            }

            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                if (this.isDragging) {
                    const deltaX = mouseX - this.lastMouseX;
                    const deltaY = mouseY - this.lastMouseY;

                    this.offsetX += deltaX;
                    this.offsetY += deltaY;

                    this.lastMouseX = mouseX;
                    this.lastMouseY = mouseY;

                    this.draw();
                } else {
                    // æ£€æŸ¥é¼ æ ‡æ‚¬åœçš„PAD
                    const worldPos = this.screenToWorld(mouseX, mouseY);
                    const hoveredPad = this.findPadAtPosition(worldPos.x, worldPos.y);

                    if (hoveredPad) {
                        this.showTooltip(hoveredPad, mouseX, mouseY);
                    } else {
                        this.hideTooltip();
                    }
                }
            }

            handleMouseUp(event) {
                this.isDragging = false;
            }

            handleWheel(event) {
                event.preventDefault();

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                const worldPos = this.screenToWorld(mouseX, mouseY);

                const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
                this.scale *= scaleFactor;

                const newScreenPos = this.worldToScreen(worldPos.x, worldPos.y);
                this.offsetX += mouseX - newScreenPos.x;
                this.offsetY += mouseY - newScreenPos.y;

                this.draw();
            }

            findPadAtPosition(x, y) {
                return this.pads.find(pad => {
                    return x >= pad.x - pad.width / 2 &&
                        x <= pad.x + pad.width / 2 &&
                        y >= pad.y - pad.height / 2 &&
                        y <= pad.y + pad.height / 2;
                });
            }

            showTooltip(pad, x, y) {
                this.tooltip.innerHTML = `
                    <div><strong>PAD ${pad.number}</strong></div>
                    <div>åç§°: ${pad.name}</div>
                    <div>ä½ç½®: (${pad.x.toFixed(1)}, ${pad.y.toFixed(1)})</div>
                    <div>å°ºå¯¸: ${pad.width.toFixed(1)} Ã— ${pad.height.toFixed(1)}</div>
                `;
                this.tooltip.style.left = (x + 10) + 'px';
                this.tooltip.style.top = (y - 10) + 'px';
                this.tooltip.style.display = 'block';
            }

            hideTooltip() {
                this.tooltip.style.display = 'none';
            }

            exportToImage() {
                const scale = 3;
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = this.canvas.width * scale;
                exportCanvas.height = this.canvas.height * scale;
                const exportCtx = exportCanvas.getContext('2d');
                exportCtx.scale(scale, scale);

                const oldCtx = this.ctx;
                const oldCanvas = this.canvas;
                this.canvas = exportCanvas;
                this.ctx = exportCtx;
                this.draw();
                this.canvas = oldCanvas;
                this.ctx = oldCtx;

                exportCanvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'chip_layout.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'image/png');
            }

            exportToPDF() {
                if (typeof window.jspdf === 'undefined' && typeof window.jsPDF === 'undefined') {
                    alert('è¯·å…ˆå¼•å…¥jsPDFåº“');
                    return;
                }
                const scale = 3;
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = this.canvas.width * scale;
                exportCanvas.height = this.canvas.height * scale;
                const exportCtx = exportCanvas.getContext('2d');
                exportCtx.scale(scale, scale);

                const oldCtx = this.ctx;
                const oldCanvas = this.canvas;
                this.canvas = exportCanvas;
                this.ctx = exportCtx;
                this.draw();
                this.canvas = oldCanvas;
                this.ctx = oldCtx;

                const imgData = exportCanvas.toDataURL('image/png');
                const pdf = window.jspdf ? new window.jspdf.jsPDF({ orientation: 'landscape' }) : new window.jsPDF({ orientation: 'landscape' });
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();
                const aspect = exportCanvas.width / exportCanvas.height;
                let w = pdfWidth, h = pdfWidth / aspect;
                if (h > pdfHeight) {
                    h = pdfHeight;
                    w = h * aspect;
                }
                pdf.addImage(imgData, 'PNG', 0, 0, w, h);
                pdf.save('chip_layout.pdf');
            }

            exportPadLSP() {
                let lspFileName = 'pad_layout.lsp';
                if (this.lastExcelFileName) {
                    lspFileName = this.lastExcelFileName.replace(/\.[^.]+$/, '_pads.lsp');
                }

                const centerX = this.chipSizeX / 2;
                const centerY = this.chipSizeY / 2;

                let lsp = "(defun c:gd ( / oldlayer ssnew basept targetpt e ed padlast padent )\n";
                lsp += "  (setq oldlayer (getvar \"CLAYER\"))\n";
                lsp += "  ;; Create 'die1' layer and set to color 4 (cyan) if not exist\n";
                lsp += "  (if (not (tblsearch \"LAYER\" \"die1\"))\n";
                lsp += "    (command \"LAYER\" \"N\" \"die1\" \"C\" \"4\" \"die1\" \"\")\n";
                lsp += "  )\n";
                lsp += "  ;; Create 'pad name' layer and set to color 5 (blue) if not exist, and make it hidden\n";
                lsp += "  (if (not (tblsearch \"LAYER\" \"pad name\"))\n";
                lsp += "    (command \"LAYER\" \"N\" \"pad name\" \"C\" \"5\" \"pad name\" \"OFF\" \"pad name\" \"\")\n";
                lsp += "  )\n";
                lsp += "  ;; Create 'pad no' layer and set to color 6 (magenta) if not exist\n";
                lsp += "  (if (not (tblsearch \"LAYER\" \"pad no\"))\n";
                lsp += "    (command \"LAYER\" \"N\" \"pad no\" \"C\" \"6\" \"pad no\" \"\")\n";
                lsp += "  )\n";
                lsp += "  (setvar \"CLAYER\" \"die1\")\n";
                lsp += "  ;; Record last entity\n";
                lsp += "  (setq lastent (entlast))\n";
                lsp += `  (command \"_rectang\" '(0 0) '(${this.chipSizeX} ${this.chipSizeY}))\n`;

                this.pads.forEach(pad => {
                    const x1 = pad.x - pad.width / 2;
                    const y1 = pad.y - pad.height / 2;
                    const x2 = pad.x + pad.width / 2;
                    const y2 = pad.y + pad.height / 2;
                    const isVSS = /VSS|VREFN/i.test(pad.name);

                    // ç»˜åˆ¶PADçŸ©å½¢ï¼ŒVSSç”¨ç»¿è‰²
                    if (isVSS) {
                        lsp += `  (setq padlast (entlast))\n`;
                        lsp += `  (command \"_rectang\" '(${x1} ${y1}) '(${x2} ${y2}))\n`;
                        lsp += `  (setq padent (entnext padlast))\n`;
                        lsp += `  (while padent (progn (setq ed (entget padent)) (if (assoc 62 ed) (setq ed (subst (cons 62 3) (assoc 62 ed) ed)) (setq ed (append ed (list (cons 62 3))))) (entmod ed) (setq padent nil)))\n`;
                    } else {
                        lsp += `  (command \"_rectang\" '(${x1} ${y1}) '(${x2} ${y2}))\n`;
                    }

                    // åˆ‡æ¢åˆ°pad noå›¾å±‚å¹¶ç»˜åˆ¶PADç¼–å·
                    lsp += `  (setvar \"CLAYER\" \"pad no\")\n`;
                    if (isVSS) {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) ${Math.min(pad.width, pad.height) * 0.5} 0 \"${pad.number}\")\n`;
                        lsp += `  (setq e (entlast)) (setq ed (entget e)) (if (assoc 62 ed) (setq ed (subst (cons 62 3) (assoc 62 ed) ed)) (setq ed (append ed (list (cons 62 3))))) (entmod ed)\n`;
                    } else {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) ${Math.min(pad.width, pad.height) * 0.5} 0 \"${pad.number}\")\n`;
                    }

                    // åˆ‡æ¢åˆ°pad nameå›¾å±‚å¹¶ç»˜åˆ¶PADåç§°
                    lsp += `  (setvar \"CLAYER\" \"pad name\")\n`;
                    // ç¡®ä¿PADåç§°æ²¡æœ‰å¤šä½™çš„ç©ºæ ¼
                    const cleanPadName = pad.name.trim();
                    if (isVSS) {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) 12 0 \"${cleanPadName}\")\n`;
                        lsp += `  (setq e (entlast)) (setq ed (entget e)) (if (assoc 62 ed) (setq ed (subst (cons 62 3) (assoc 62 ed) ed)) (setq ed (append ed (list (cons 62 3))))) (entmod ed)\n`;
                    } else {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) 12 0 \"${cleanPadName}\")\n`;
                    }
                    // åˆ‡æ¢å›die1å›¾å±‚
                    lsp += `  (setvar \"CLAYER\" \"die1\")\n`;
                });

                lsp += "  ;; Select all newly created objects for moving (including pad names)\n";
                lsp += "  (setq ssnew (ssadd))\n";
                lsp += "  (setq ent (entnext lastent))\n";
                lsp += "  (while ent (progn (ssadd ent ssnew) (setq ent (entnext ent))))\n";
                lsp += "  ;; Also select all objects on pad name and pad no layers\n";
                lsp += "  (setq ss-padnames (ssget \"X\" (list (cons 8 \"pad name\"))))\n";
                lsp += "  (if ss-padnames\n";
                lsp += "    (progn\n";
                lsp += "      (setq i 0)\n";
                lsp += "      (while (< i (sslength ss-padnames))\n";
                lsp += "        (ssadd (ssname ss-padnames i) ssnew)\n";
                lsp += "        (setq i (+ i 1))\n";
                lsp += "      )\n";
                lsp += "    )\n";
                lsp += "  )\n";
                lsp += "  (setq ss-padnos (ssget \"X\" (list (cons 8 \"pad no\"))))\n";
                lsp += "  (if ss-padnos\n";
                lsp += "    (progn\n";
                lsp += "      (setq i 0)\n";
                lsp += "      (while (< i (sslength ss-padnos))\n";
                lsp += "        (ssadd (ssname ss-padnos i) ssnew)\n";
                lsp += "        (setq i (+ i 1))\n";
                lsp += "      )\n";
                lsp += "    )\n";
                lsp += "  )\n";
                lsp += "  ;; Use standard MOVE command for interactive movement\n";
                lsp += '  (princ "\\nPlease select a base point and then move the die to desired location...")\n';
                lsp += '  (command "_move" ssnew "" pause pause)\n';
                lsp += '  (princ "\n--- Drawing completed on die1 layer ---\n")\n';
                lsp += "  ;; Restore original layer at the end\n";
                lsp += "  (setvar \"CLAYER\" oldlayer)\n";
                lsp += ")\n(princ)\n";

                const blob = new Blob([lsp], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = lspFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            exportD2PadLSP() {
                if (!this.hasD2Chip || this.d2Pads.length === 0) {
                    alert('æ²¡æœ‰D2èŠ¯ç‰‡æ•°æ®å¯å¯¼å‡º');
                    return;
                }

                let lspFileName = 'd2_pad_layout.lsp';
                if (this.lastExcelFileName) {
                    lspFileName = this.lastExcelFileName.replace(/\.[^.]+$/, '_d2_pads.lsp');
                }

                let lsp = "(defun c:gd2 ( / oldlayer ssnew basept targetpt e ed padlast padent )\n";
                lsp += "  (setq oldlayer (getvar \"CLAYER\"))\n";
                lsp += "  ;; Create 'die2' layer and set to color 4 (cyan) if not exist\n";
                lsp += "  (if (not (tblsearch \"LAYER\" \"die2\"))\n";
                lsp += "    (command \"LAYER\" \"N\" \"die2\" \"C\" \"4\" \"die2\" \"\")\n";
                lsp += "  )\n";
                lsp += "  ;; Create 'pad name' layer and set to color 5 (blue) if not exist, and make it hidden\n";
                lsp += "  (if (not (tblsearch \"LAYER\" \"pad name\"))\n";
                lsp += "    (command \"LAYER\" \"N\" \"pad name\" \"C\" \"5\" \"pad name\" \"OFF\" \"pad name\" \"\")\n";
                lsp += "  )\n";
                lsp += "  ;; Create 'pad no' layer and set to color 6 (magenta) if not exist\n";
                lsp += "  (if (not (tblsearch \"LAYER\" \"pad no\"))\n";
                lsp += "    (command \"LAYER\" \"N\" \"pad no\" \"C\" \"6\" \"pad no\" \"\")\n";
                lsp += "  )\n";
                lsp += "  (setvar \"CLAYER\" \"die2\")\n";
                lsp += "  ;; Record last entity\n";
                lsp += "  (setq lastent (entlast))\n";
                lsp += `  (command \"_rectang\" '(0 0) '(${this.d2ChipSizeX} ${this.d2ChipSizeY}))\n`;

                this.d2Pads.forEach(pad => {
                    const x1 = pad.x - pad.width / 2;
                    const y1 = pad.y - pad.height / 2;
                    const x2 = pad.x + pad.width / 2;
                    const y2 = pad.y + pad.height / 2;
                    const isVSS = /VSS|VREFN/i.test(pad.name);

                    // D2çš„PADç¼–å·æ ¼å¼ï¼šD2.1, D2.2ç­‰
                    const d2PadNumber = `D2.${pad.number}`;
                    // PADåç§°å»æ‰å†’å·
                    const cleanPadName = pad.name.replace(/:$/, '').trim();

                    // ç»˜åˆ¶PADçŸ©å½¢ï¼ŒVSSç”¨ç»¿è‰²
                    if (isVSS) {
                        lsp += `  (setq padlast (entlast))\n`;
                        lsp += `  (command \"_rectang\" '(${x1} ${y1}) '(${x2} ${y2}))\n`;
                        lsp += `  (setq padent (entnext padlast))\n`;
                        lsp += `  (while padent (progn (setq ed (entget padent)) (if (assoc 62 ed) (setq ed (subst (cons 62 3) (assoc 62 ed) ed)) (setq ed (append ed (list (cons 62 3))))) (entmod ed) (setq padent nil)))\n`;
                    } else {
                        lsp += `  (command \"_rectang\" '(${x1} ${y1}) '(${x2} ${y2}))\n`;
                    }

                    // åˆ‡æ¢åˆ°pad noå›¾å±‚å¹¶ç»˜åˆ¶PADç¼–å·ï¼ˆD2.1æ ¼å¼ï¼‰
                    lsp += `  (setvar \"CLAYER\" \"pad no\")\n`;
                    if (isVSS) {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) ${Math.min(pad.width, pad.height) * 0.5} 0 \"${d2PadNumber}\")\n`;
                        lsp += `  (setq e (entlast)) (setq ed (entget e)) (if (assoc 62 ed) (setq ed (subst (cons 62 3) (assoc 62 ed) ed)) (setq ed (append ed (list (cons 62 3))))) (entmod ed)\n`;
                    } else {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) ${Math.min(pad.width, pad.height) * 0.5} 0 \"${d2PadNumber}\")\n`;
                    }

                    // åˆ‡æ¢åˆ°pad nameå›¾å±‚å¹¶ç»˜åˆ¶PADåç§°ï¼ˆå»æ‰å†’å·ï¼‰
                    lsp += `  (setvar \"CLAYER\" \"pad name\")\n`;
                    if (isVSS) {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) 12 0 \"${cleanPadName}\")\n`;
                        lsp += `  (setq e (entlast)) (setq ed (entget e)) (if (assoc 62 ed) (setq ed (subst (cons 62 3) (assoc 62 ed) ed)) (setq ed (append ed (list (cons 62 3))))) (entmod ed)\n`;
                    } else {
                        lsp += `  (command \"_text\" \"J\" \"MC\" '(${pad.x} ${pad.y}) 12 0 \"${cleanPadName}\")\n`;
                    }
                    // åˆ‡æ¢å›die2å›¾å±‚
                    lsp += `  (setvar \"CLAYER\" \"die2\")\n`;
                });

                lsp += "  ;; Select all newly created D2 objects (die2 layer + pad name/no created after lastent)\n";
                lsp += "  (setq ssnew (ssadd))\n";
                lsp += "  (setq ent (entnext lastent))\n";
                lsp += "  (while ent (progn (ssadd ent ssnew) (setq ent (entnext ent))))\n";
                lsp += "  ;; Use standard MOVE command for interactive movement\n";
                lsp += '  (princ "\\nPlease select a base point and then move the D2 die to desired location...")\n';
                lsp += '  (command "_move" ssnew "" pause pause)\n';
                lsp += '  (princ "\n--- D2 Drawing completed on die2 layer ---\n")\n';
                lsp += "  ;; Restore original layer at the end\n";
                lsp += "  (setvar \"CLAYER\" oldlayer)\n";
                lsp += ")\n(princ)\n";

                const blob = new Blob([lsp], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = lspFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            exportWireLSP() {
                let lspFileName = 'wire_connections.lsp';
                if (this.lastExcelFileName) {
                    lspFileName = this.lastExcelFileName.replace(/\.[^.]+$/, '_wires.lsp');
                }

                let lsp = `;; Wire Drawing Script
;; Generated automatically from Excel data
;; This script draws lines between pins and pads based on connection data

(defun c:drawwires ()
  (setq oldlayer (getvar "CLAYER"))
  
  ;; Create or set the wire layer
  (if (not (tblsearch "LAYER" "wire"))
    (command "LAYER" "N" "wire" "C" "2" "wire" "")
  )
  (setvar "CLAYER" "wire")
  
  (princ "\\nStarting wire drawing process...")
  (setq error-count 0)
  (setq success-count 0)
  
`;

                this.wireConnections.forEach(conn => {
                    // åˆ›å»ºpinå·çš„å¤§å°å†™å˜ä½“
                    const pinLower = conn.pin.toLowerCase();
                    const pinUpper = conn.pin.toUpperCase();

                    // å¦‚æœpinä»¥pæˆ–På¼€å¤´ï¼Œåˆ›å»ºå¦ä¸€ç§å¤§å°å†™å˜ä½“
                    let pinAlt = null;
                    if (conn.pin.startsWith('p')) {
                        pinAlt = 'P' + conn.pin.substring(1);
                    } else if (conn.pin.startsWith('P')) {
                        pinAlt = 'p' + conn.pin.substring(1);
                    }

                    lsp += `
  ;; Process PIN ${conn.pin} to PAD ${conn.pad}
  (setq pin-text "${conn.pin}")
  (setq pad-text "${conn.pad}")
  (setq pin-coord nil)
 
  
  ;; Find PIN text and get coordinates (case-insensitive)
  ;; Create case variations of the pin text
  (setq pin-text-lower (strcase pin-text nil))  ;; Convert to lowercase (e.g., "p1")
  (setq pin-text-upper (strcase pin-text))      ;; Convert to uppercase (e.g., "P1")
  
  ;; If pin text starts with "p" or "P", also try the other case version
  (if (= (substr pin-text 1 1) "p")
      (setq pin-text-alt (strcat "P" (substr pin-text 2)))
      (if (= (substr pin-text 1 1) "P")
          (setq pin-text-alt (strcat "p" (substr pin-text 2)))
          (setq pin-text-alt nil)
      )
  )
  
  ;; Try with original text
  (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text))))
  (if (not ss-pin)
    (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text))))
  )
  
  ;; Try with uppercase version if not found
  (if (not ss-pin)
    (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text-upper))))
  )
  (if (not ss-pin)
    (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text-upper))))
  )
  
  ;; Try with lowercase version if still not found
  (if (not ss-pin)
    (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text-lower))))
  )
  (if (not ss-pin)
    (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text-lower))))
  )
  
  ;; Try with alternative p/P version if still not found
  (if (and (not ss-pin) pin-text-alt)
    (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text-alt))))
  )
  (if (and (not ss-pin) pin-text-alt)
    (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text-alt))))
  )
  (if ss-pin
    (progn
      (setq pin-ent (ssname ss-pin 0))
      (setq pin-data (entget pin-ent))
      (setq pin-coord (cdr (assoc 11 pin-data))) ;; ä¼˜å…ˆç”¨å¯¹é½ç‚¹ï¼ˆè§†è§‰ä¸­å¿ƒï¼‰
      (if (not pin-coord)
        (setq pin-coord (cdr (assoc 10 pin-data))) ;; æ²¡æœ‰åˆ™ç”¨æ’å…¥ç‚¹
      )
    )
    (progn
      (princ (strcat "\nWarning: PIN text '" pin-text "' not found"))
      (setq error-count (+ error-count 1))
    )
  )
  
  ;; Find PAD text and get coordinates (æœç´¢PADç¼–å·ï¼Œä¸æ˜¯PADåç§°)
  (setq ss-pad (ssget "X" (list (cons 0 "TEXT") (cons 1 pad-text))))
  (if (not ss-pad)
    (setq ss-pad (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad-text))))
  )
  (if ss-pad
    (progn
      (setq pad-ent (ssname ss-pad 0))
      (setq pad-data (entget pad-ent))
      (setq pad-coord (cdr (assoc 11 pad-data))) ;; ä¼˜å…ˆç”¨å¯¹é½ç‚¹ï¼ˆè§†è§‰ä¸­å¿ƒï¼‰
      (if (not pad-coord)
        (setq pad-coord (cdr (assoc 10 pad-data))) ;; æ²¡æœ‰åˆ™ç”¨æ’å…¥ç‚¹
      )
    )
    (progn
      (princ (strcat "\nWarning: PAD text '" pad-text "' not found"))
      (setq error-count (+ error-count 1))
    )
  )
  
  ;; Draw line if both coordinates found
  (if (and pin-coord pad-coord)
    (progn
      (entmakex (list (cons 0 "LINE") (cons 8 "wire") (cons 62 2) (cons 10 pin-coord) (cons 11 pad-coord)))
      (setq success-count (+ success-count 1))
      (princ (strcat "\nConnected " pin-text " to " pad-text))
    )
    (progn
      (princ (strcat "\nFailed to connect " pin-text " to " pad-text))
      (setq error-count (+ error-count 1))
    )
  )
`;
                });

                // æ·»åŠ PAD to PADè¿çº¿ç”Ÿæˆé€»è¾‘
                if (this.padToPadConnections && this.padToPadConnections.length > 0) {
                    lsp += `
  ;; Process PAD to PAD connections
  (princ "\\nProcessing PAD to PAD connections...")
`;

                    this.padToPadConnections.forEach(conn => {
                        if (conn.type === 'die1-to-die1') {
                            // die1å†…éƒ¨çš„pad to padè¿çº¿
                            lsp += `
  ;; PAD ${conn.pad1} to PAD ${conn.pad2} (die1 to die1)
  (setq pad1-text "${conn.pad1}")
  (setq pad2-text "${conn.pad2}")
  (setq pad1-coord nil)
  (setq pad2-coord nil)
  
  ;; Find PAD1 number text
  (setq ss-pad1 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad1-text) (cons 8 "pad no"))))
  (if (not ss-pad1) (setq ss-pad1 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad1-text) (cons 8 "pad no")))))
  (if (not ss-pad1) (setq ss-pad1 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad1-text)))))
  (if (not ss-pad1) (setq ss-pad1 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad1-text)))))
  
  (if ss-pad1
    (progn
      (setq pad1-ent (ssname ss-pad1 0))
      (setq pad1-data (entget pad1-ent))
      (setq pad1-coord (cdr (assoc 11 pad1-data)))
      (if (not pad1-coord) (setq pad1-coord (cdr (assoc 10 pad1-data))))
    )
  )
  
  ;; Find PAD2 number text
  (setq ss-pad2 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad2-text) (cons 8 "pad no"))))
  (if (not ss-pad2) (setq ss-pad2 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad2-text) (cons 8 "pad no")))))
  (if (not ss-pad2) (setq ss-pad2 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad2-text)))))
  (if (not ss-pad2) (setq ss-pad2 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad2-text)))))
  
  (if ss-pad2
    (progn
      (setq pad2-ent (ssname ss-pad2 0))
      (setq pad2-data (entget pad2-ent))
      (setq pad2-coord (cdr (assoc 11 pad2-data)))
      (if (not pad2-coord) (setq pad2-coord (cdr (assoc 10 pad2-data))))
    )
  )
  
  ;; Draw line if both coordinates found
  (if (and pad1-coord pad2-coord)
    (progn
      (entmakex (list (cons 0 "LINE") (cons 8 "wire") (cons 62 2) (cons 10 pad1-coord) (cons 11 pad2-coord)))
      (setq success-count (+ success-count 1))
      (princ "\\nPAD ${conn.pad1} to PAD ${conn.pad2} connected")
    )
    (progn
      (princ "\\nWarning: Failed to connect PAD ${conn.pad1} to PAD ${conn.pad2}")
      (setq error-count (+ error-count 1))
    )
  )
`;
                        } else if (conn.type === 'die1-to-die2') {
                            // die1åˆ°die2çš„è¿çº¿ï¼Œéœ€è¦åœ¨D2ä¸­æŸ¥æ‰¾å¯¹åº”çš„pad
                            const searchText = conn.d2SearchText.toUpperCase();
                            const d2Pad = this.d2Pads.find(p => {
                                const padName = p.name.replace(/:$/, '').trim().toUpperCase();
                                // åªè¦æœç´¢æ–‡æœ¬åŒ…å«pad nameå°±ç®—åŒ¹é…
                                return searchText.includes(padName);
                            });

                            if (d2Pad) {
                                const d2PadNumber = `D2.${d2Pad.number}`;
                                lsp += `
  ;; PAD ${conn.pad1} to D2 PAD ${d2Pad.number} (die1 to die2, search: ${conn.d2SearchText})
  (setq pad1-text "${conn.pad1}")
  (setq pad2-text "${d2PadNumber}")
  (setq pad1-coord nil)
  (setq pad2-coord nil)
  
  ;; Find die1 PAD number text
  (setq ss-pad1 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad1-text) (cons 8 "pad no"))))
  (if (not ss-pad1) (setq ss-pad1 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad1-text) (cons 8 "pad no")))))
  (if (not ss-pad1) (setq ss-pad1 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad1-text)))))
  (if (not ss-pad1) (setq ss-pad1 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad1-text)))))
  
  (if ss-pad1
    (progn
      (setq pad1-ent (ssname ss-pad1 0))
      (setq pad1-data (entget pad1-ent))
      (setq pad1-coord (cdr (assoc 11 pad1-data)))
      (if (not pad1-coord) (setq pad1-coord (cdr (assoc 10 pad1-data))))
    )
  )
  
  ;; Find D2 PAD number text
  (setq ss-pad2 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad2-text) (cons 8 "pad no"))))
  (if (not ss-pad2) (setq ss-pad2 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad2-text) (cons 8 "pad no")))))
  (if (not ss-pad2) (setq ss-pad2 (ssget "X" (list (cons 0 "TEXT") (cons 1 pad2-text)))))
  (if (not ss-pad2) (setq ss-pad2 (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad2-text)))))
  
  (if ss-pad2
    (progn
      (setq pad2-ent (ssname ss-pad2 0))
      (setq pad2-data (entget pad2-ent))
      (setq pad2-coord (cdr (assoc 11 pad2-data)))
      (if (not pad2-coord) (setq pad2-coord (cdr (assoc 10 pad2-data))))
    )
  )
  
  ;; Draw line if both coordinates found
  (if (and pad1-coord pad2-coord)
    (progn
      (entmakex (list (cons 0 "LINE") (cons 8 "wire") (cons 62 2) (cons 10 pad1-coord) (cons 11 pad2-coord)))
      (setq success-count (+ success-count 1))
      (princ "\\nPAD ${conn.pad1} to D2.${d2Pad.number} connected")
    )
    (progn
      (princ "\\nWarning: Failed to connect PAD ${conn.pad1} to D2.${d2Pad.number}")
      (setq error-count (+ error-count 1))
    )
  )
`;
                            } else {
                                console.warn(`æœªæ‰¾åˆ°D2ä¸­åŒ¹é…"${conn.d2SearchText}"çš„PAD`);
                            }
                        }
                    });
                }

                // æ·»åŠ L/Fè¿çº¿ç”Ÿæˆé€»è¾‘
                if (this.lfConnections && this.lfConnections.length > 0) {
                    lsp += `
  ;; Process L/F connections (pad to L/F and pin to L/F)
  (princ "\\nProcessing L/F connections...")
`;

                    this.lfConnections.forEach(conn => {
                        if (conn.type === 'pad') {
                            // pad to L/F: æ‰¾åˆ°å¯¹åº”çš„PADç¼–å·ï¼Œä»PADç¼–å·è¿1000umçº¿
                            const padText = conn.number.toString();
                            const pad = this.pads.find(p => p.number.toString() === padText);

                            if (pad) {
                                // è®¡ç®—PADåˆ°å››æ¡è¾¹çš„è·ç¦»
                                const distToLeft = pad.x;
                                const distToRight = this.chipSizeX - pad.x;
                                const distToBottom = pad.y;
                                const distToTop = this.chipSizeY - pad.y;

                                // æ‰¾å‡ºæœ€å°è·ç¦»ï¼Œåˆ¤æ–­PADåœ¨å“ªæ¡è¾¹
                                const minDist = Math.min(distToLeft, distToRight, distToBottom, distToTop);

                                let direction = '';
                                let offsetX = 0;
                                let offsetY = 0;

                                if (minDist === distToLeft) {
                                    // å·¦è¾¹ -> å¾€å·¦è¿çº¿
                                    direction = 'left';
                                    offsetX = -1000;
                                    offsetY = 0;
                                } else if (minDist === distToRight) {
                                    // å³è¾¹ -> å¾€å³è¿çº¿
                                    direction = 'right';
                                    offsetX = 1000;
                                    offsetY = 0;
                                } else if (minDist === distToBottom) {
                                    // ä¸‹è¾¹ -> å¾€ä¸‹è¿çº¿
                                    direction = 'bottom';
                                    offsetX = 0;
                                    offsetY = -1000;
                                } else {
                                    // ä¸Šè¾¹ -> å¾€ä¸Šè¿çº¿
                                    direction = 'top';
                                    offsetX = 0;
                                    offsetY = 1000;
                                }

                                lsp += `
  ;; PAD ${conn.number} to L/F (direction: ${direction}, offset: ${offsetX}, ${offsetY})
  ;; Find PAD number text and draw line from it
  (setq pad-text "${padText}")
  (setq ss-pad (ssget "X" (list (cons 0 "TEXT") (cons 1 pad-text) (cons 8 "pad no"))))
  (if (not ss-pad) (setq ss-pad (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad-text) (cons 8 "pad no")))))
  (if (not ss-pad) (setq ss-pad (ssget "X" (list (cons 0 "TEXT") (cons 1 pad-text)))))
  (if (not ss-pad) (setq ss-pad (ssget "X" (list (cons 0 "MTEXT") (cons 1 pad-text)))))
  
  (if ss-pad
    (progn
      (setq pad-ent (ssname ss-pad 0))
      (setq pad-data (entget pad-ent))
      (setq pad-coord (cdr (assoc 11 pad-data)))
      (if (not pad-coord) (setq pad-coord (cdr (assoc 10 pad-data))))
      
      ;; Get PAD coordinates
      (setq pad-x (car pad-coord))
      (setq pad-y (cadr pad-coord))
      (setq pad-z (caddr pad-coord))
      
      ;; Calculate end point: direction is ${direction}
      (setq end-x (+ pad-x ${offsetX}))
      (setq end-y (+ pad-y ${offsetY}))
      
      (entmakex (list (cons 0 "LINE") (cons 8 "wire") (cons 62 3) (cons 10 pad-coord) (cons 11 (list end-x end-y pad-z))))
      (setq success-count (+ success-count 1))
      (princ "\\nPAD ${conn.number} to L/F connected (${direction})")
    )
    (progn
      (princ "\\nWarning: PAD number ${conn.number} not found for L/F connection")
      (setq error-count (+ error-count 1))
    )
  )
`;
                            }
                        } else if (conn.type === 'pin') {
                            // pin to L/F: ä»PINè¿1000umçº¿ï¼Œæ ¹æ®PINç¼–å·åˆ†ç»„åˆ¤æ–­æ–¹å‘
                            const pinNumber = parseInt(conn.number);
                            const totalPins = this.totalPinCount || 144; // é»˜è®¤144ä¸ªPIN
                            const pinsPerSide = Math.floor(totalPins / 4);

                            // åˆ¤æ–­PINåœ¨å“ªä¸€è¾¹
                            let direction = '';
                            let offsetX = 0;
                            let offsetY = 0;

                            if (pinNumber >= 1 && pinNumber <= pinsPerSide) {
                                // ç¬¬1ç»„ï¼šå·¦è¾¹çš„PINï¼Œå¾€å³è¿çº¿
                                direction = 'right (from left)';
                                offsetX = 1000;
                                offsetY = 0;
                            } else if (pinNumber > pinsPerSide && pinNumber <= pinsPerSide * 2) {
                                // ç¬¬2ç»„ï¼šä¸‹é¢çš„PINï¼Œå¾€ä¸Šè¿çº¿
                                direction = 'up (from bottom)';
                                offsetX = 0;
                                offsetY = 1000;
                            } else if (pinNumber > pinsPerSide * 2 && pinNumber <= pinsPerSide * 3) {
                                // ç¬¬3ç»„ï¼šå³è¾¹çš„PINï¼Œå¾€å·¦è¿çº¿
                                direction = 'left (from right)';
                                offsetX = -1000;
                                offsetY = 0;
                            } else {
                                // ç¬¬4ç»„ï¼šä¸Šé¢çš„PINï¼Œå¾€ä¸‹è¿çº¿
                                direction = 'down (from top)';
                                offsetX = 0;
                                offsetY = -1000;
                            }

                            const pinText = `p${conn.number}`;

                            lsp += `
  ;; PIN ${conn.number} to L/F (total pins: ${totalPins}, group: ${Math.ceil(pinNumber / pinsPerSide)})
  (setq pin-text "${pinText}")
  (setq pin-coord nil)
  
  ;; Find PIN text (case-insensitive)
  (setq pin-text-lower (strcase pin-text nil))
  (setq pin-text-upper (strcase pin-text))
  (setq pin-text-alt (strcat "P" (substr pin-text 2)))
  
  (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text))))
  (if (not ss-pin) (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text)))))
  (if (not ss-pin) (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text-upper)))))
  (if (not ss-pin) (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text-upper)))))
  (if (not ss-pin) (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text-lower)))))
  (if (not ss-pin) (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text-lower)))))
  (if (not ss-pin) (setq ss-pin (ssget "X" (list (cons 0 "TEXT") (cons 1 pin-text-alt)))))
  (if (not ss-pin) (setq ss-pin (ssget "X" (list (cons 0 "MTEXT") (cons 1 pin-text-alt)))))
  
  (if ss-pin
    (progn
      (setq pin-ent (ssname ss-pin 0))
      (setq pin-data (entget pin-ent))
      (setq pin-coord (cdr (assoc 11 pin-data)))
      (if (not pin-coord) (setq pin-coord (cdr (assoc 10 pin-data))))
      
      (setq pin-x (car pin-coord))
      (setq pin-y (cadr pin-coord))
      (setq pin-z (caddr pin-coord))
      
      ;; æ ¹æ®PINç¼–å·åˆ†ç»„è®¡ç®—æ–¹å‘
      (setq end-x (+ pin-x ${offsetX}))
      (setq end-y (+ pin-y ${offsetY}))
      
      (entmakex (list (cons 0 "LINE") (cons 8 "wire") (cons 62 3) (cons 10 pin-coord) (cons 11 (list end-x end-y pin-z))))
      (setq success-count (+ success-count 1))
      (princ "\\nPIN ${conn.number} to L/F connected (${direction})")
    )
    (progn
      (princ "\\nWarning: PIN ${conn.number} not found for L/F connection")
      (setq error-count (+ error-count 1))
    )
  )
`;
                        }
                    });
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰L/Fè¿çº¿
                const hasLFConnections = this.lfConnections && this.lfConnections.length > 0;

                lsp += `
  ;; Restore original layer
  (setvar "CLAYER" oldlayer)

  ;; Report results
  (princ (strcat "\nWire drawing completed!"))
  (princ (strcat "\nSuccessful connections: " (itoa success-count)))
  (princ (strcat "\nErrors/warnings: " (itoa error-count)))
  (princ "\nAll wires have been placed on layer 'wire'")
`;

                // å¦‚æœæœ‰L/Fè¿çº¿ï¼Œæ·»åŠ é€‰ä¸­ç»¿è‰²çº¿çš„ä»£ç 
                if (hasLFConnections) {
                    lsp += `
  
  ;; Select all green L/F wires (color 3) on wire layer
  (princ "\\nSelecting all L/F connections (green wires)...")
  (setq ss-lf (ssget "X" (list (cons 0 "LINE") (cons 8 "wire") (cons 62 3))))
  (if ss-lf
    (progn
      (sssetfirst nil ss-lf)
      (princ (strcat "\\n" (itoa (sslength ss-lf)) " L/F connections selected (green wires)"))
    )
    (princ "\\nNo L/F connections found to select")
  )
`;
                }

                lsp += `
  (princ)
)

;; Load message
(princ "\\nWire Drawing Script Loaded!")
(princ "\\nType 'drawwires' to execute the wire drawing process.")
(princ)
`;

                const blob = new Blob([lsp], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = lspFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new IntegratedChipTool();
        });
    </script>
</body>

</html>